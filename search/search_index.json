{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-hallmd","title":"Contributing to <code>hallmd</code>","text":"<p>You might be here if you want to:</p> <ul> <li>Report a bug</li> <li>Discuss the current state of the code</li> <li>Submit a fix</li> <li>Propose a new feature</li> <li>Write unit tests</li> <li>Add to the documentation</li> </ul> <p>We use Github to host code and documentation, to track issues and feature requests, and to accept pull requests.</p>"},{"location":"contributing/#submitting-pull-requests","title":"Submitting pull requests","text":"<p>Pull requests are the best way to propose changes to the codebase (bug fixes, new features, docs, etc.)</p> <ol> <li>Fork the repo and create a branch from <code>main</code>.</li> <li>If you are adding a feature or making major changes, first create the issue in Github.</li> <li>If you've added code that should be tested, add to <code>/tests</code>.</li> <li>If you've made major changes, update the <code>/docs</code>.</li> <li>Ensure the test suite passes (<code>pdm run test</code>).</li> <li>Follow Conventional commits guidelines when adding a commit message.</li> <li>Ensure all <code>pre-commit</code> checks pass. Pro tip: use <code>pdm lint</code> to help.</li> <li>Issue the pull request!</li> </ol> <p>Use pdm to set up your development environment. An example contribution workflow is shown here:</p> <pre><code>git clone https://github.com/JANUS-Institute/HallThrusterPEM.git\ncd HallThrusterPEM\npdm install\ngit checkout -b &lt;your-branch-name&gt;\n\n# Make local changes\n\npdm run test  # make sure tests pass\ngit add -A\ngit commit -m \"fix: adding a bugfix\"\ngit push -u origin &lt;your-branch-name&gt;\n\n# Go to Github and \"Compare &amp; Pull Request\" on your branch\n# For your PR to be merged:\n  # squash all your commits on your branch (interactively in an IDE most likely)\n  # rebase to the top of origin/main to include new changes from others\n\ngit fetch\ngit rebase -i main your-branch  # for example\n\n# Resolve any conflicts\n# Your history now looks something like this:\n#              o your-branch\n#             /\n# ---o---o---o main\n\n# You can delete the branch when your PR has been merged\n</code></pre> <p>You can also find a good tutorial here.</p>"},{"location":"contributing/#report-bugs-using-issues","title":"Report bugs using issues","text":"<p>Open a new issue and describe your problem using the template. Provide screenshots where possible and example log files. Add labels to help categorize and describe your issue.</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the GPL-3.0 license.</p>"},{"location":"coverage/","title":"Coverage report","text":""},{"location":"examples/","title":"Examples","text":"<p>Coming soon. Short examples to showcase the usage/features.</p>"},{"location":"examples/#spt-100-data","title":"SPT-100 data","text":"<p>Load and plot SPT-100 experimental data.</p>"},{"location":"examples/#simple-model-configuration","title":"Simple model configuration","text":"<p>Show a simple <code>amisc</code> example and its config file.</p>"},{"location":"examples/#hallthrusterjl-configuration","title":"HallThruster.jl configuration","text":"<p>Repeat, but with the built-in HallThruster.jl model.</p>"},{"location":"examples/#monte-carlo","title":"Monte Carlo","text":"<p>Show a simple UQ plot (i.e. sample, predict, plot)</p>"},{"location":"examples/#model-calibration","title":"Model calibration","text":"<p>Show a simple run of least-squares or MCMC with plots.</p>"},{"location":"start/","title":"Getting started","text":"<p>A prototype of a predictive engineering model (PEM) of a Hall thruster. Integrates sub-models from multiple disciplines to simulate a Hall thruster operating in a vacuum chamber. Uses uncertainty quantification techniques to extrapolate model predictions to a space-like environment.</p>"},{"location":"start/#installation","title":"\u2699\ufe0f Installation","text":"<p>Ensure you are using Python 3.11 or later. You can install using pdm: <pre><code>pip install --user pdm\ngit clone https://github.com/JANUS-Institute/HallThrusterPEM.git  # or download the source from releases\ncd HallThrusterPEM\npdm install --prod\n</code></pre></p> <p><code>hallmd</code> uses the <code>HallThruster.jl</code> Julia package. Please see their docs for setting up Julia and installing. Alternatively, you may run the provided install script, which will install both Julia and <code>HallThruster.jl</code>. By default, this will install Julia 1.11 and HallThruster.jl version 0.18.7. From the root directory, run the following command:</p> <pre><code>pdm run scripts/install_hallthruster.py --julia-version=X.XX.X --hallthruster-version=V.VV.V\n</code></pre> <p>This will create a fresh Julia environment called <code>hallthruster_V.VV.V</code> and install <code>HallThruster.jl</code> there.</p>"},{"location":"start/#scripts-used-for-publications","title":"\ud83d\udccd Scripts used for publications","text":"<p>See the scripts folder for workflows for data generation, parameter inference, and analysis using <code>hallmd</code>. This directory also contains information needed to replicate the results in our publications.</p>"},{"location":"start/#standalone-usage","title":"\ud83d\udccd Standalone usage","text":"<p>Below, we demonstrate how to use <code>hallmd</code> to run HallThruster.jl on a simple config file.</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom hallmd.models import hallthruster_jl\n\nconfig = {\n    'discharge_voltage': 300,\n    'anode_mass_flow_rate': 5e-6,\n    'background_pressure_Torr': 1e-5,\n    'propellant': 'Xenon',\n    'domain': [0, 0.08]\n}\n\noutputs = hallthruster_jl(thruster='SPT-100', config=config)\n\nion_velocity = outputs['u_ion']\ngrid = outputs['u_ion_coords']\n\nfig, ax = plt.subplots()\nax.plot(grid, ion_velocity)\nax.set_xlabel('Axial location (m)')\nax.set_ylabel('Ion velocity (m/s)')\nplt.show()\n</code></pre>"},{"location":"start/#project-structure","title":"\ud83d\uddc2\ufe0f Project structure","text":"<pre><code>\ud83d\udcc1 HallThrusterPEM\n\u251c\u2500\u2500 \ud83d\udcc1 docs/\n\u251c\u2500\u2500 \ud83d\udcc1 scripts/           # Scripts for building predictive engineering models (PEMs)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 pem_v0/        # PEM v0 coupling of cathode -&gt; thruster -&gt; plume\n\u251c\u2500\u2500 \ud83d\udcc1 src/hallmd         # Python package source code root\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 models/        # Python wrappers for sub-models\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 data/          # Experimental data\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 devices/       # Device information (thrusters, equipment, etc.)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 utils.py       # Utility functions\n\u251c\u2500\u2500 \ud83d\udcc1 tests/             # Testing for Python package\n\u2514\u2500\u2500 \ud83d\udcc4 pdm.lock           # Frozen dependencies file\n</code></pre> <p>For more info on building PEMs with <code>hallmd</code>, see the scripts.</p>"},{"location":"start/#contributing","title":"\ud83c\udfd7\ufe0f Contributing","text":"<p>See the contribution guidelines.</p>"},{"location":"start/#reference","title":"\ud83d\udcd6 Reference","text":"<p>[1] Eckels, J. et al., \"Hall thruster model improvement by multidisciplinary uncertainty quantification,\" Journal of Electric Propulsion, vol 3, no 19, September 2024.</p>"},{"location":"start/#funding-declaration","title":"Funding declaration","text":"<p>Funding for this work was provided by NASA in part through the Joint Advanced Propulsion Institute (JANUS), a NASA Space Technology Research Institute, under grant number 80NSSC21K1118, as well as in part through a NASA Space Technology Graduate Research Opportunity grant 80NSSC23K1181. This research was additionally supported in part through computational resources provided by Advanced Research Computing at the University of Michigan.</p> <p><sup><sub>Made with the copier-numpy template.</sub></sup></p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Coming soon (would be good to do this in a jupyter notebook).</p>"},{"location":"tutorial/#setup","title":"Setup","text":"<ul> <li>Installation, Julia environments, changing HallThruster.jl versions</li> </ul>"},{"location":"tutorial/#using-the-models","title":"Using the models","text":"<ul> <li>Built-in cathode, thruster, plume models</li> </ul>"},{"location":"tutorial/#linking-models","title":"Linking models","text":"<ul> <li>First do a \"manual\" passing of info between models</li> <li>Then show an amisc config.yml file (more info in amisc docs)</li> </ul>"},{"location":"tutorial/#loading-data","title":"Loading data","text":"<ul> <li>Show how to access experimental data</li> </ul>"},{"location":"tutorial/#advanced-features","title":"Advanced features","text":"<ul> <li>Surrogate and UQ analysis (see how-to guides for details, just give a taste here)</li> <li>Model calibration</li> </ul>"},{"location":"guides/calibrate/","title":"Calibrate a model","text":"<p>Coming soon. Walkthrough of MCMC calibration and the likelihood. Requires running a model and loading experimental data.</p>"},{"location":"guides/data/","title":"Load experimental data","text":"<p>Coming soon.</p>"},{"location":"guides/model/","title":"Run a Hall thruster model","text":"<p>Coming soon. Include config file setup, model linking, and <code>system.predict()</code>. Use <code>scripts/pem_v0</code> as an example.</p>"},{"location":"guides/surrogate/","title":"Build a surrogate","text":"<p>Coming soon. Uses the <code>amisc</code> surrogate framework and the <code>scripts/train.sh</code> script.</p>"},{"location":"guides/validate/","title":"Validate a model","text":"<p>Coming soon. Last step of comparing model to data and determining goodness-of-fit.</p>"},{"location":"reference/","title":"<code>hallmd</code>","text":"<p>Prototype of a predictive engineering model (PEM) of a Hall thruster. Integrates sub-models from multiple disciplines to simulate a Hall thruster operating in a vacuum chamber. Uses uncertainty quantification techniques to extrapolate model predictions to a space-like environment.</p> <ul> <li>Authors - Joshua Eckels (eckelsjd@umich.edu), Thomas Marks, Madison Allen, Declan Brick, Benjamin Jorns, Alex Gorodetsky</li> <li>License - GPL-3.0</li> </ul> <p>The <code>hallmd</code> package contains three sub-packages:</p> <ul> <li><code>models</code> - Contains the sub-models for each discipline in the Hall thruster system.</li> <li><code>devices</code> - Contains information about specific devices (thrusters and other equipment).</li> <li><code>data</code> - Contains experimental data for validating the models.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> hallmd</li> <li> data<ul> <li> h9</li> <li> spt100<ul> <li> diamant2014</li> <li> express2001</li> <li> macdonald2019</li> <li> sankovic1993</li> </ul> </li> </ul> </li> <li> devices</li> <li> models<ul> <li> cathode</li> <li> plume</li> <li> thruster</li> </ul> </li> <li> utils</li> </ul>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#hallmd.utils","title":"<code>hallmd.utils</code>","text":"<p>Module to provide utilities for the <code>hallmd</code> package.</p> <p>Includes:</p> <ul> <li><code>load_device()</code> - Load a device configuration from the <code>hallmd.devices</code> directory.</li> </ul>"},{"location":"reference/utils/#hallmd.utils.load_device","title":"<code>load_device(device_name, device_file='device.yml', device_dir=None)</code>","text":"<p>Load a device configuration from the <code>device_dir</code> directory. The <code>device_file</code> must be located at <code>device_dir/device_name/device_file</code>. All other files in the directory, if referenced in <code>device_file</code>, will be converted to an absolute path.</p> <p>Loading a device configuration</p> <p>Currently, the only provided device configuration is for the SPT-100 thruster. <pre><code>from hallmd.utils import load_device\n\ndevice = load_device('SPT-100')\n</code></pre></p> <p>You may put custom configurations in the <code>hallmd.devices</code> directory or specify a custom directory with a custom configuration file: <pre><code>name: MyDevice\ngeometry:\n  channel_length: 1\n  inner_radius: 2\n  outer_radius: 3\nmagnetic_field:\n  file: bfield.csv\nshielded: false\n</code></pre></p> PARAMETER DESCRIPTION <code>device_name</code> <p>name of the device configuration to load</p> <p> TYPE: <code>str</code> </p> <code>device_file</code> <p>name of the device configuration file (default: 'device.yml'). Only supported file types are <code>.yml</code> and <code>.json</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'device.yml'</code> </p> <code>device_dir</code> <p>directory containing the devices. If None, the <code>hallmd.devices</code> directory is used.</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>dictionary containing the device configuration</p> Source code in <code>src/hallmd/utils.py</code> <pre><code>def load_device(device_name: str, device_file: str = 'device.yml', device_dir: str | Path = None) -&gt; dict:\n    \"\"\"Load a device configuration from the `device_dir` directory. The `device_file` must be located at\n    `device_dir/device_name/device_file`. All other files in the directory, if referenced in `device_file`, will\n    be converted to an absolute path.\n\n    !!! Example \"Loading a device configuration\"\n        Currently, the only provided device configuration is for the SPT-100 thruster.\n        ```python\n        from hallmd.utils import load_device\n\n        device = load_device('SPT-100')\n        ```\n\n    You may put custom configurations in the `hallmd.devices` directory or specify a custom directory with a custom\n    configuration file:\n    ```yaml\n    name: MyDevice\n    geometry:\n      channel_length: 1\n      inner_radius: 2\n      outer_radius: 3\n    magnetic_field:\n      file: bfield.csv\n    shielded: false\n    ```\n\n    :param device_name: name of the device configuration to load\n    :param device_file: name of the device configuration file (default: 'device.yml'). Only supported file types are\n                        `.yml` and `.json`.\n    :param device_dir: directory containing the devices. If None, the `hallmd.devices` directory is used.\n    :return: dictionary containing the device configuration\n    \"\"\"\n    device_dir = resources.files('hallmd.devices') if device_dir is None else Path(device_dir)\n    if not (device_dir / device_name).exists():\n        raise FileNotFoundError(f'Device directory \"{device_name}\" not found in the device folder.')\n    if not (device_dir / device_name / device_file).exists():\n        raise FileNotFoundError(f'Device configuration file \"{device_file}\" not found in the \"{device_name}\" '\n                                f'directory. Please rename or specify the configuration file as \"{device_file}\".')\n\n    config_file = device_dir / device_name / device_file\n    with open(config_file, 'r', encoding='utf-8') as fd:\n        if config_file.suffix == '.yml':\n            config = yaml.safe_load(fd)\n        elif config_file.suffix == '.json':\n            config = json.load(fd)\n        else:\n            raise ValueError(f'Unsupported file type \"{config_file.suffix}\". Only .yml and .json files are supported.')\n\n    # Convert all relative paths to absolute paths\n    for root, _, files in os.walk(device_dir / device_name):\n        for file in files:\n            if file != device_file:\n                # Check if the posix file path from root is in the config (i.e. \"./file.csv\")\n                root_path = Path(root) / file  # Path like \"hallmd/devices/SPT-100/path/to/file.csv\"\n                rel_path = root_path.relative_to(device_dir / device_name)  # Just the path/to/file.csv part (relative)\n                dict_path = _path_in_dict(rel_path.as_posix(), config)\n                if len(dict_path) == 0:\n                    # Check if the plain filename is in the config (i.e. file.csv); will only pick first match\n                    dict_path = _path_in_dict(file, config)\n\n                if dict_path:\n                    d = config  # pointer to the nested location in config\n                    for key in dict_path[:-2]:\n                        d = config[key]\n                    d[dict_path[-2]] = root_path.resolve().as_posix()\n\n    return config\n</code></pre>"},{"location":"reference/data/","title":"<code>hallmd.data</code>","text":"<p>The <code>hallmd.data</code> package contains a folder for each unique thruster. The experimental data for each thruster is further divided by folders for each individual paper or reference. The raw experimental data is contained within these folders in any supported format (currently only .csv). Any additional documentation for the datasets is encouraged (e.g. citations, descriptions, summaries, etc.) and can be included in the data folders.</p>"},{"location":"reference/data/#hallmd.data--thrusters","title":"Thrusters","text":""},{"location":"reference/data/#hallmd.data--spt-100","title":"SPT-100","text":"<p>Currently the only thruster with available data. Data for the SPT-100 comes from four sources:</p> <ol> <li>Diamant et al. 2014 - provides thrust and ion current density data as a function of chamber background pressure.</li> <li>Macdonald et al. 2019 - provides ion velocity profiles for varying chamber pressures.</li> <li>Sankovic et al. 1993 - provides thrust at varying operating conditions.</li> <li>Jorns and Byrne. 2021 - provides cathode coupling voltages at same conditions as Diamant et al. 2014.</li> </ol> <p>Citations: SPT-100.bib<pre><code>@incollection{diamantEffectBackgroundPressure2014,\n    title = {The {{Effect}} of {{Background Pressure}} on {{SPT-100 Hall\n             Thruster Performance}}},\n    booktitle = {50th {{AIAA}}/{{ASME}}/{{SAE}}/{{ASEE Joint Propulsion\n                 Conference}}},\n    author = {Diamant, Kevin D. and Liang, Raymond and Corey, Ron L.},\n    date = {2014-07-25},\n    series = {{{AIAA Propulsion}} and {{Energy Forum}}},\n    publisher = {{American Institute of Aeronautics and Astronautics}},\n    doi = {10.2514/6.2014-3710},\n    year = {2014},\n}\n\n@article{macdonaldBackgroundPressureEffects2019,\n    title = {Background {{Pressure Effects}} on {{Ion Velocity Distributions}}\n             in an {{SPT-100 Hall Thruster}}},\n    author = {Macdonald-Tenenbaum, Natalia and Pratt, Quinn and Nakles, Michael\n              and Pilgram, Nickolas and Holmes, Michael and Hargus, William},\n    date = {2019-01-11},\n    journaltitle = {Journal of Propulsion and Power},\n    shortjournal = {Journal of Propulsion and Power},\n    volume = {35},\n    pages = {1--10},\n    doi = {10.2514/1.B37133},\n}\n\n@inproceedings{sankovicPerformanceEvaluationRussian1993,\n    title = {Performance Evaluation of the {{Russian SPT-100}} Thruster at {{\n             NASA LeRC}}},\n    author = {Sankovic, J. and Hamley, J. and Haag, T.},\n    date = {1993-09-13/1993-09-16},\n    location = {{Seattle, WA, USA}},\n    url = {\n           https://www.semanticscholar.org/paper/Performance-evaluation-of-the-Russian-SPT-100-at-Sankovic-Hamley/81b7d985669b21aa1a8419277c52e7a879bf3b46\n           },\n    urldate = {2023-01-06},\n    eventtitle = {23rd {{International Electric Propulsion Conference}}},\n}\n\n@article{jornsCathodeCoupling2021,\n    title = {Model for the dependence of cathode voltage in a {H}all thruster on\n             facility pressure},\n    author = {Jorns, Benjamin A. and Byrne, Matthew P.},\n    date = {2021-01-12},\n    journaltitle = {Plasma Sources Science and Technology},\n    volume = {30},\n    number = {1},\n    pages = {015012},\n    publisher = {IOP Publishing},\n    doi = {10.1088/1361-6595/abd3b6},\n}\n</code></pre></p>"},{"location":"reference/data/#hallmd.data--data-conventions","title":"Data conventions","text":"<p>The data used in the PEM is expected to be in a standard format. This format may evolve over time to account for more data, but at present, when we read a CSV file, here is what we look for in the columns. Note that we treat columns case-insensitively, so <code>Anode current (A)</code> is treated the same as <code>anode current (a)</code>.</p>"},{"location":"reference/data/#hallmd.data--operating-conditions","title":"Operating conditions","text":"<p>Data is imported into a dictionary that maps operating conditions to data. An Operating Condition (made concrete in the <code>OperatingCondition</code> class) consists of a unique set of an anode mass flow rate, a background pressure, and a discharge / anode voltage. These quantities are mandatory for each data file, but can be provided in a few ways. In cases where multiple options are allowed, the first matching column is chosen.</p>"},{"location":"reference/data/#hallmd.data--background-pressure","title":"Background pressure","text":"<p>We expect a column named 'background pressure (torr)' (not case sensitive). We assume the pressure is in units of Torr.</p>"},{"location":"reference/data/#hallmd.data--anode-mass-flow-rate","title":"Anode mass flow rate","text":"<p>We look for the following column names in order:</p> <ol> <li>A column named 'anode flow rate (mg/s)',</li> <li>A column named 'total flow rate (mg/s)' and a column named 'anode-cathode flow ratio',</li> <li>A column named 'total flow rate (mg/s)' and a column named 'cathode flow fraction'.</li> </ol> <p>In all cases, the unit of the flow rate is expected to be mg/s. For option 2, the cathode flow fraction is expected as a fraction between zero and one. For option 3, the anode-cathode flow ratio is unitless and is expected to be greater than one.</p>"},{"location":"reference/data/#hallmd.data--discharge-voltage","title":"Discharge voltage","text":"<p>We look for the following column names in order:</p> <ol> <li>'discharge voltage (v)',</li> <li>'anode voltage (v)'</li> </ol> <p>In both cases, the unit of the voltage is expected to be Volts.</p>"},{"location":"reference/data/#hallmd.data--data","title":"Data","text":"<p>The following data-fields are all optional. The <code>ThrusterData</code> struct will be populated only with what is provided. For each of these quantities, an uncertainty can be provided, either relative or absolute. The formats for uncertainties for a quantity of the form '{quantity} ({unit})' are 1. '{quantity} absolute uncertainty ({unit})' 2. '{quantity} relative uncertainty'</p> <p>Relative uncertainties are fractions (so 0.2 == 20%) and absolute uncertainties are in the same units as the main quantity.</p> <p>As an example, thrust of 100 mN and a relative uncertainty of 0.05 represents 100 +/- 5 mN. We assume the errors are normally distributed about the nominal value with the uncertainty representing two standard deviations. In this case, the distribution of the experimentally-measured thrust would be T ~ N(100, 2.5). If both relative and absolute uncertainties are provided, we use the absolute uncertainty. If an uncertainty is not provided, a relative uncertainty of 2% is assumed.</p>"},{"location":"reference/data/#hallmd.data--thrust","title":"Thrust","text":"<p>We look for a column called 'thrust (mn)' or 'thrust (n)'. We then convert the thrust to Newtons internally.</p>"},{"location":"reference/data/#hallmd.data--discharge-current","title":"Discharge current","text":"<p>We look for one of the following column names in order:</p> <ol> <li>'discharge current (a)'</li> <li>'anode current (a)'</li> </ol>"},{"location":"reference/data/#hallmd.data--cathode-coupling-voltage","title":"Cathode coupling voltage","text":"<p>We look for a column called 'cathode coupling voltage (v)'.</p>"},{"location":"reference/data/#hallmd.data--ionbeam-current","title":"Ion/beam current","text":"<p>We look for one of the following column names in order: 1. 'ion current (a)' 2. 'beam current (a)' 3. 'ion beam current (a)'</p>"},{"location":"reference/data/#hallmd.data--ion-current-density","title":"Ion current density","text":"<p>We look for three columns</p> <ol> <li> <p>The radial distance from the thruster exit plane. Allowed keys: 'radial position from thruster exit (m)'</p> </li> <li> <p>The angle relative to thruster centerline Allowed keys: 'angular position from thruster centerline (deg)'</p> </li> <li> <p>The current density. Allowed keys: 'ion current density (ma/cm^2)' or 'ion current density (a/m^2)'</p> </li> </ol> <p>We do not look for uncertainties for the radius and angle. The current density is assumed to have units of mA / cm^2 or A / m^2, depending on the key. If one or two of these quantities is provided, we throw an error.</p>"},{"location":"reference/data/#hallmd.data--ion-velocity","title":"Ion velocity","text":"<p>We look for two columns:</p> <ol> <li> <p>Axial position from anode Allowed keys: 'axial position from anode (m)'</p> </li> <li> <p>Ion velocity Allowed keys: 'ion velocity (m/s)'</p> </li> </ol> <p>We do not look for uncertainties for the axial position. The ion velocity is assumed to have units of m/s. If only one of these quantities is provided, we throw an error.</p>"},{"location":"reference/data/#hallmd.data.opcond_keys","title":"<code>opcond_keys = {'p_b': 'background_pressure_torr', 'v_a': 'discharge_voltage_v', 'mdot_a': 'anode_mass_flow_rate_kg_s'}</code>  <code>module-attribute</code>","text":"<p>Forward mapping between operating condition short and long names.</p>"},{"location":"reference/data/#hallmd.data.CurrentDensitySweep","title":"<code>CurrentDensitySweep(radius_m, angles_rad, current_density_A_m2)</code>  <code>dataclass</code>","text":"<p>Contains data for a single current density sweep.</p> ATTRIBUTE DESCRIPTION <code>radius_m</code> <p>the radial distance (in m) from the thruster exit plane at which the sweep was obtained.</p> <p> TYPE: <code>float64</code> </p> <code>angles_rad</code> <p>the angular measurement locations (in rad) from thruster centerline.</p> <p> TYPE: <code>Array</code> </p> <code>current_density_A_m2</code> <p>the measured current density in (A/m^2) at all measurement locations.</p> <p> TYPE: <code>Measurement[Array]</code> </p>"},{"location":"reference/data/#hallmd.data.IonVelocityData","title":"<code>IonVelocityData(axial_distance_m, velocity_m_s)</code>  <code>dataclass</code>","text":"<p>Contains measurements of axial ion velocity along with coordinates.</p> ATTRIBUTE DESCRIPTION <code>axial_distance_m</code> <p>the axial channel distance (in m) from the anode where the measurements were taken.</p> <p> TYPE: <code>Array</code> </p> <code>velocity_m_s</code> <p>the ion velocity measurements obtained from LIF (in m/s).</p> <p> TYPE: <code>Measurement[Array]</code> </p>"},{"location":"reference/data/#hallmd.data.Measurement","title":"<code>Measurement(mean, std)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A measurement object that includes a mean and standard deviation. The mean is the best estimate of the quantity being measured, and the standard deviation is the uncertainty in the measurement. Can be used to specify a scalar measurement quantity or a field quantity (e.g. a profile) in the form of a <code>numpy</code> array.</p>"},{"location":"reference/data/#hallmd.data.OperatingCondition","title":"<code>OperatingCondition(background_pressure_torr, discharge_voltage_v, anode_mass_flow_rate_kg_s)</code>  <code>dataclass</code>","text":"<p>Operating conditions for a Hall thruster.</p> ATTRIBUTE DESCRIPTION <code>background_pressure_torr</code> <p>the background pressure in Torr.</p> <p> TYPE: <code>float</code> </p> <code>discharge_voltage_v</code> <p>the discharge voltage in Volts.</p> <p> TYPE: <code>float</code> </p> <code>anode_mass_flow_rate_kg_s</code> <p>the anode mass flow rate in kg/s.</p> <p> TYPE: <code>float</code> </p>"},{"location":"reference/data/#hallmd.data.ThrusterData","title":"<code>ThrusterData(cathode_coupling_voltage_V=None, thrust_N=None, discharge_current_A=None, ion_current_A=None, efficiency_current=None, efficiency_mass=None, efficiency_voltage=None, efficiency_anode=None, ion_velocity=None, ion_current_sweeps=None)</code>  <code>dataclass</code>","text":"<p>Class for Hall thruster data. Contains fields for all relevant performance metrics and quantities of interest. All metrics are time-averaged unless otherwise noted. A <code>ThrusterData</code> instance can contain as many or as few fields as needed, depending on the available data.</p> ATTRIBUTE DESCRIPTION <code>cathode_coupling_voltage_V</code> <p>the cathode coupling voltage (V)</p> <p> TYPE: <code>Optional[Measurement[float64]]</code> </p> <code>thrust_N</code> <p>the thrust (N)</p> <p> TYPE: <code>Optional[Measurement[float64]]</code> </p> <code>discharge_current_A</code> <p>the discharge current (A)</p> <p> TYPE: <code>Optional[Measurement[float64]]</code> </p> <code>efficiency_current</code> <p>the current efficiency</p> <p> TYPE: <code>Optional[Measurement[float64]]</code> </p> <code>efficiency_mass</code> <p>the mass efficiency</p> <p> TYPE: <code>Optional[Measurement[float64]]</code> </p> <code>efficiency_voltage</code> <p>the voltage efficiency</p> <p> TYPE: <code>Optional[Measurement[float64]]</code> </p> <code>efficiency_anode</code> <p>the anode efficiency</p> <p> TYPE: <code>Optional[Measurement[float64]]</code> </p> <code>ion_velocity</code> <p>the axial ion velocity data</p> <p> TYPE: <code>Optional[IonVelocityData]</code> </p> <code>ion_current_sweeps</code> <p>a list of current density sweeps</p> <p> TYPE: <code>Optional[list[CurrentDensitySweep]]</code> </p>"},{"location":"reference/data/#hallmd.data.ThrusterData.update","title":"<code>update(data1, data2)</code>  <code>staticmethod</code>","text":"<p>Return a new <code>ThrusterData</code> instance with merged fields from <code>data1</code> and <code>data2</code>.</p> Source code in <code>src/hallmd/data/__init__.py</code> <pre><code>@staticmethod\ndef update(data1: 'ThrusterData', data2: 'ThrusterData') -&gt; 'ThrusterData':\n    \"\"\"Return a new `ThrusterData` instance with merged fields from `data1` and `data2`.\"\"\"\n    merged = {}\n    for field in fields(ThrusterData):\n        merged[field.name] = ThrusterData._merge_field(field.name, data1, data2)\n    return ThrusterData(**merged)\n</code></pre>"},{"location":"reference/data/#hallmd.data.ThrusterDataset","title":"<code>ThrusterDataset</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for thruster datasets. A thruster dataset provides paths to experimental data files for a specific thruster.</p>"},{"location":"reference/data/#hallmd.data.ThrusterDataset.all_data","title":"<code>all_data()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Return a list of paths to all datasets for this thruster.</p> Source code in <code>src/hallmd/data/__init__.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef all_data() -&gt; list[Path]:\n    \"\"\"Return a list of paths to all datasets for this thruster.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/data/#hallmd.data.ThrusterDataset.datasets_from_names","title":"<code>datasets_from_names(dataset_names)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Return a list of paths to the datasets with the given names.</p> Source code in <code>src/hallmd/data/__init__.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef datasets_from_names(dataset_names: list[str]) -&gt; list[Path]:\n    \"\"\"Return a list of paths to the datasets with the given names.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/data/#hallmd.data.get_thruster","title":"<code>get_thruster(name)</code>","text":"<p>Return a thruster dataset object based on the given thruster name.</p> PARAMETER DESCRIPTION <code>name</code> <p>the name of the thruster to get data for</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/hallmd/data/__init__.py</code> <pre><code>def get_thruster(name: str) -&gt; ThrusterDataset:\n    \"\"\"Return a thruster dataset object based on the given thruster name.\n\n    :param name: the name of the thruster to get data for\n    \"\"\"\n    if name.casefold() in {'h9'}:\n        from .h9 import H9\n\n        return H9\n    elif name.casefold() in {'spt-100', 'spt100'}:\n        from .spt100 import SPT100\n\n        return SPT100\n    else:\n        raise ValueError(f\"Invalid thruster name {name}.\")\n</code></pre>"},{"location":"reference/data/#hallmd.data.load","title":"<code>load(files)</code>","text":"<p>Load all data from the given files into a dict map of <code>OperatingCondition</code> -&gt; <code>ThrusterData</code>. Each thruster operating condition corresponds to one set of thruster measurements or quantities of interest (QoIs).</p> PARAMETER DESCRIPTION <code>files</code> <p>A list of file paths or a single file path to load data from (only .csv supported).</p> <p> TYPE: <code>Sequence[PathLike] | PathLike</code> </p> RETURNS DESCRIPTION <code>dict[OperatingCondition, ThrusterData]</code> <p>A dict map of <code>OperatingCondition</code> -&gt; <code>ThrusterData</code> objects.</p> Source code in <code>src/hallmd/data/__init__.py</code> <pre><code>def load(files: Sequence[PathLike] | PathLike) -&gt; dict[OperatingCondition, ThrusterData]:\n    \"\"\"Load all data from the given files into a dict map of `OperatingCondition` -&gt; `ThrusterData`.\n    Each thruster operating condition corresponds to one set of thruster measurements or quantities of interest (QoIs).\n\n    :param files: A list of file paths or a single file path to load data from (only .csv supported).\n    :return: A dict map of `OperatingCondition` -&gt; `ThrusterData` objects.\n    \"\"\"\n    data: dict[OperatingCondition, ThrusterData] = {}\n    if isinstance(files, list):\n        # Recursively load resources in this list (possibly list of lists)\n        for file in files:\n            new_data = load(file)\n            data = _update_data(data, new_data)\n    else:\n        new_data = _load_single_file(files)\n        data = _update_data(data, new_data)\n\n    return data\n</code></pre>"},{"location":"reference/data/#hallmd.data.pem_to_thrusterdata","title":"<code>pem_to_thrusterdata(operating_conditions, outputs, sweep_radii, use_corrected_thrust=True)</code>","text":"<p>Given a list of operating conditions and an <code>outputs</code> dict from amisc, construct a <code>dict</code> mapping the operating conditions to <code>ThrusterData</code> objects. Note: we assume that the amisc outputs are ordered based on the input operating conditions.</p> PARAMETER DESCRIPTION <code>operating_conditions</code> <p>A list of <code>OperatingConditions</code> at which the pem was run.</p> <p> TYPE: <code>list[OperatingCondition]</code> </p> <code>outputs</code> <p>the amisc output dict from the run</p> <p> TYPE: <code>dict</code> </p> <code>sweep_radii</code> <p>an array of radii at which ion current density data was taken</p> <p> TYPE: <code>Array</code> </p> <code>use_corrected_thrust</code> <p>Whether to use the base thrust from HallThruster.jl or the thrust corrected by the divergence angle computed in the plume model.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/hallmd/data/__init__.py</code> <pre><code>def pem_to_thrusterdata(\n    operating_conditions: list[OperatingCondition], outputs: dict, sweep_radii: Array, use_corrected_thrust: bool = True\n) -&gt; Optional[dict[OperatingCondition, ThrusterData]]:\n    \"\"\"Given a list of operating conditions and an `outputs` dict from amisc,\n    construct a `dict` mapping the operating conditions to `ThrusterData` objects.\n    Note: we assume that the amisc outputs are ordered based on the input operating conditions.\n\n    :param operating_conditions: A list of `OperatingConditions` at which the pem was run.\n    :param outputs: the amisc output dict from the run\n    :param sweep_radii: an array of radii at which ion current density data was taken\n    :param use_corrected_thrust: Whether to use the base thrust from HallThruster.jl or the thrust corrected by the\n           divergence angle computed in the plume model.\n    \"\"\"  # noqa: E501\n\n    # Check to make sure all keys that we expect to be there are there\n    if not _amisc_output_is_valid(outputs, len(operating_conditions)):\n        return None\n\n    output_dict = {\n        opcond: _single_opcond_to_thrusterdata(i, outputs, sweep_radii, use_corrected_thrust)\n        for (i, opcond) in enumerate(operating_conditions)\n    }\n\n    return output_dict\n</code></pre>"},{"location":"reference/data/h9/","title":"<code>hallmd.data.h9</code>","text":"<p>Module for H9 datasets.</p>"},{"location":"reference/data/h9/#hallmd.data.h9.H9","title":"<code>H9</code>","text":"<p>               Bases: <code>ThrusterDataset</code></p> <p>Class for handling the H9 datasets.</p>"},{"location":"reference/data/spt100/","title":"<code>hallmd.data.spt100</code>","text":"<p>Module for SPT-100 datasets.</p>"},{"location":"reference/data/spt100/#hallmd.data.spt100.SPT100","title":"<code>SPT100</code>","text":"<p>               Bases: <code>ThrusterDataset</code></p> <p>Class for handling the SPT-100 datasets.</p>"},{"location":"reference/data/spt100/diamant2014/","title":"<code>hallmd.data.spt100.diamant2014</code>","text":""},{"location":"reference/data/spt100/express2001/","title":"<code>hallmd.data.spt100.express2001</code>","text":""},{"location":"reference/data/spt100/macdonald2019/","title":"<code>hallmd.data.spt100.macdonald2019</code>","text":""},{"location":"reference/data/spt100/sankovic1993/","title":"<code>hallmd.data.spt100.sankovic1993</code>","text":""},{"location":"reference/devices/","title":"<code>hallmd.devices</code>","text":"<p>Sub-package to host information about devices (thrusters, chambers, other equipment, etc.).</p>"},{"location":"reference/models/","title":"<code>hallmd.models</code>","text":"<p>All models are specified as callable functions in <code>hallmd.models</code>. Currently supported models are based on a three-component feedforward system for a Hall thruster:</p> <ol> <li>Cathode - Accounts for interactions of the cathode plasma with the main discharge.</li> <li>Thruster - The primary simulation of the Hall thruster channel discharge and near-field.</li> <li>Plume - Models the far-field expansion of the plasma plume in the vacuum chamber.</li> </ol> <p></p> <p>Fig 1. The three-component feedforward Hall thruster model (Eckels et al 2024).</p> <p>Examples of integrated predictive engineering models (PEM) are included in the scripts folder.</p>"},{"location":"reference/models/#hallmd.models.cathode_coupling","title":"<code>cathode_coupling(inputs)</code>","text":"<p>Computes cathode coupling voltage dependence on background pressure.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>input arrays - <code>P_b</code>, <code>V_a</code>, <code>T_e</code>, <code>V_vac</code>, <code>Pstar</code>, <code>P_T</code> for background pressure (Torr), discharge voltage (V), electron temperature (eV), vacuum coupling voltage (V), and model parameters P* (Torr) and P_T (Torr).</p> <p> TYPE: <code>Dataset</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>output arrays - <code>V_cc</code> for cathode coupling voltage (V).</p> Source code in <code>src/hallmd/models/cathode.py</code> <pre><code>def cathode_coupling(inputs: Dataset) -&gt; Dataset:\n    \"\"\"Computes cathode coupling voltage dependence on background pressure.\n\n    :param inputs: input arrays - `P_b`, `V_a`, `T_e`, `V_vac`, `Pstar`, `P_T` for background pressure (Torr), discharge\n                   voltage (V), electron temperature (eV), vacuum coupling voltage (V), and model parameters P* (Torr)\n                   and P_T (Torr).\n    :returns outputs: output arrays - `V_cc` for cathode coupling voltage (V).\n    \"\"\"\n    # Load inputs\n    PB = inputs['P_b'] * TORR_2_PA          # Background Pressure (Torr)\n    Va = inputs['V_a']                      # Anode voltage (V)\n    Te = inputs['T_e']                      # Electron temperature at the cathode (eV)\n    V_vac = inputs['V_vac']                 # Vacuum coupling voltage model parameter (V)\n    Pstar = inputs['Pstar'] * TORR_2_PA     # Model parameter P* (Torr)\n    PT = inputs['P_T'] * TORR_2_PA          # Model parameter P_T (Torr)\n\n    # Compute cathode coupling voltage\n    V_cc = np.atleast_1d(V_vac + Te * np.log(1 + PB / PT) - (Te / (PT + Pstar)) * PB)\n    V_cc[V_cc &lt; 0] = 0\n    ind = np.where(V_cc &gt; Va)\n    V_cc[ind] = np.atleast_1d(Va)[ind]\n    return {'V_cc': V_cc}\n</code></pre>"},{"location":"reference/models/#hallmd.models.current_density","title":"<code>current_density(inputs, sweep_radius=1.0)</code>","text":"<p>Compute the semi-empirical ion current density (\\(j_{ion}\\)) plume model over a 90 deg sweep, with 0 deg at thruster centerline. Also compute the plume divergence angle. Will return the ion current density at 91 points, from 0 to 90 deg in 1 deg increments. The angular locations are returned as <code>j_ion_coords</code> in radians.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>input arrays - <code>P_b</code>, <code>c0</code>, <code>c1</code>, <code>c2</code>, <code>c3</code>, <code>c4</code>, <code>c5</code>, <code>sigma_cex</code>, <code>I_B0</code> for background pressure (Torr), plume fit coefficients, charge-exchange cross-section (\\(m^2\\)), and total initial ion beam current (A). If <code>T</code> is provided, then also compute corrected thrust using the divergence angle.</p> <p> TYPE: <code>Dataset</code> </p> <code>sweep_radius</code> <p>the location(s) at which to compute the ion current density 90 deg sweep, in units of radial distance (m) from the thruster exit plane. If multiple locations are provided, then the returned \\(j_{ion}\\) array's last dimension will match the length of <code>sweep_radius</code>. Defaults to 1 meter.</p> <p> TYPE: <code>float | list</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <p>output arrays - <code>j_ion</code> for ion current density (\\(A/m^2\\)) at the <code>j_ion_coords</code> locations, and <code>div_angle</code> in radians for the divergence angle of the plume. Optionally, <code>T_c</code> for corrected thrust (N) if <code>T</code> is provided in the inputs.</p> Source code in <code>src/hallmd/models/plume.py</code> <pre><code>def current_density(inputs: Dataset, sweep_radius: float | list = 1.0):\n    \"\"\"Compute the semi-empirical ion current density ($j_{ion}$) plume model over a 90 deg sweep, with 0 deg at\n    thruster centerline. Also compute the plume divergence angle. Will return the ion current density at 91 points,\n    from 0 to 90 deg in 1 deg increments. The angular locations are returned as `j_ion_coords` in radians.\n\n    :param inputs: input arrays - `P_b`, `c0`, `c1`, `c2`, `c3`, `c4`, `c5`, `sigma_cex`, `I_B0` for background\n                   pressure (Torr), plume fit coefficients, charge-exchange cross-section ($m^2$),\n                   and total initial ion beam current (A). If `T` is provided, then\n                   also compute corrected thrust using the divergence angle.\n    :param sweep_radius: the location(s) at which to compute the ion current density 90 deg sweep, in units of radial\n                         distance (m) from the thruster exit plane. If multiple locations are provided, then the\n                         returned $j_{ion}$ array's last dimension will match the length of `sweep_radius`. Defaults to\n                         1 meter.\n    :returns outputs: output arrays - `j_ion` for ion current density ($A/m^2$) at the `j_ion_coords` locations,\n                                       and `div_angle` in radians for the divergence angle of the plume. Optionally,\n                                       `T_c` for corrected thrust (N) if `T` is provided in the inputs.\n    \"\"\"\n    # Load plume inputs\n    P_B = inputs['P_b'] * TORR_2_PA  # Background pressure (Torr)\n    c0 = inputs['c0']  # Fit coefficients (-)\n    c1 = inputs['c1']  # (-)\n    c2 = inputs['c2']  # (rad/Pa)\n    c3 = inputs['c3']  # (rad)\n    c4 = inputs['c4']  # (m^-3/Pa)\n    c5 = inputs['c5']  # (m^-3)\n    sigma_cex = inputs['sigma_cex']  # Charge-exchange cross-section (m^2)\n    I_B0 = inputs['I_B0']  # Total initial ion beam current (A)\n    thrust = inputs.get('T', None)  # Thrust (N)\n    sweep_radius = np.atleast_1d(sweep_radius)\n\n    # 90 deg angle sweep for ion current density\n    alpha_rad = np.linspace(0, np.pi / 2, 91)\n\n    # Neutral density\n    n = c4 * P_B + c5  # m^-3\n\n    # Divergence angles\n    alpha1 = np.atleast_1d(c2 * P_B + c3)  # Main beam divergence (rad)\n    alpha1[alpha1 &gt; np.pi / 2] = np.pi / 2\n    alpha2 = alpha1 / c1  # Scattered beam divergence (rad)\n\n    with np.errstate(invalid='ignore', divide='ignore'):\n        A1 = (1 - c0) / (\n            (np.pi ** (3 / 2))\n            / 2\n            * alpha1\n            * np.exp(-((alpha1 / 2) ** 2))\n            * (\n                2 * erfi(alpha1 / 2)\n                + erfi((np.pi * 1j - (alpha1**2)) / (2 * alpha1))\n                - erfi((np.pi * 1j + (alpha1**2)) / (2 * alpha1))\n            )\n        )\n        A2 = c0 / (\n            (np.pi ** (3 / 2))\n            / 2\n            * alpha2\n            * np.exp(-((alpha2 / 2) ** 2))\n            * (\n                2 * erfi(alpha2 / 2)\n                + erfi((np.pi * 1j - (alpha2**2)) / (2 * alpha2))\n                - erfi((np.pi * 1j + (alpha2**2)) / (2 * alpha2))\n            )\n        )\n        # Broadcast over angles and radii (..., a, r)\n        A1 = np.expand_dims(A1, axis=(-1, -2))  # (..., 1, 1)\n        A2 = np.expand_dims(A2, axis=(-1, -2))\n        alpha1 = np.expand_dims(alpha1, axis=(-1, -2))\n        alpha2 = np.expand_dims(alpha2, axis=(-1, -2))\n        I_B0 = np.expand_dims(I_B0, axis=(-1, -2))\n        n = np.expand_dims(n, axis=(-1, -2))\n        sigma_cex = np.expand_dims(sigma_cex, axis=(-1, -2))\n\n        decay = np.exp(-sweep_radius * n * sigma_cex)  # (..., 1, r)\n        j_cex = I_B0 * (1 - decay) / (2 * np.pi * sweep_radius**2)\n\n        base_density = I_B0 * decay / sweep_radius**2\n        j_beam = base_density * A1 * np.exp(-((alpha_rad[..., np.newaxis] / alpha1) ** 2))\n        j_scat = base_density * A2 * np.exp(-((alpha_rad[..., np.newaxis] / alpha2) ** 2))\n\n        j_ion = j_beam + j_scat + j_cex  # (..., 91, r) the current density 1d profile at r radial locations\n\n    # Set j~0 where alpha1 &lt; 0 (invalid cases)\n    invalid_idx = np.logical_or(np.any(alpha1 &lt;= 0, axis=(-1, -2)), np.any(j_ion &lt;= 0, axis=(-1, -2)))\n    j_ion[invalid_idx, ...] = 1e-20\n    j_cex[invalid_idx, ...] = 1e-20\n\n    if np.any(abs(j_ion.imag) &gt; 0):\n        LOGGER.warning('Predicted beam current has non-zero imaginary component.')\n    j_ion = j_ion.real\n\n    # Calculate divergence angle from https://aip.scitation.org/doi/10.1063/5.0066849\n    # Requires alpha = [0, ..., 90] deg, from thruster exit-plane to thruster centerline (need to flip)\n    # do j_beam + j_scat instead of j_ion - j_cex to avoid catastrophic loss of precision when\n    # j_beam and j_scat &lt;&lt; j_cex\n    j_non_cex = np.flip((j_beam + j_scat).real, axis=-2)\n    den_integrand = j_non_cex * np.cos(alpha_rad[..., np.newaxis])\n    num_integrand = den_integrand * np.sin(alpha_rad[..., np.newaxis])\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        num = simpson(num_integrand, x=alpha_rad, axis=-2)\n        den = simpson(den_integrand, x=alpha_rad, axis=-2)\n        cos_div = np.atleast_1d(num / den)\n        cos_div[cos_div == np.inf] = np.nan\n\n    div_angle = np.arccos(cos_div)  # Divergence angle (rad) - (..., r)\n\n    # Squeeze last dim if only a single radius was passed\n    if sweep_radius.shape[0] == 1:\n        j_ion = np.squeeze(j_ion, axis=-1)\n        div_angle = np.squeeze(div_angle, axis=-1)\n\n    ret = {'j_ion': j_ion, 'div_angle': div_angle}\n\n    if thrust is not None:\n        thrust_corrected = np.expand_dims(thrust, axis=-1) * cos_div\n        if sweep_radius.shape[0] == 1:\n            thrust_corrected = np.squeeze(thrust_corrected, axis=-1)\n        ret['T_c'] = thrust_corrected\n\n    # Interpolate to requested angles\n    # if j_ion_coords is not None:\n    #     # Extend to range (-90, 90) deg\n    #     alpha_grid = np.concatenate((-np.flip(alpha_rad)[:-1], alpha_rad))               # (2M-1,)\n    #     jion_grid = np.concatenate((np.flip(j_ion, axis=-1)[..., :-1], j_ion), axis=-1)  # (..., 2M-1)\n    #\n    #     f = interp1d(alpha_grid, jion_grid, axis=-1)\n    #     j_ion = f(j_ion_coords)  # (..., num_pts)\n\n    # Broadcast coords to same loop shape as j_ion (all use the same coords -- store in object array)\n    last_axis = -1 if sweep_radius.shape[0] == 1 else -2\n    j_ion_coords = np.empty(j_ion.shape[:last_axis], dtype=object)\n    for index in np.ndindex(j_ion.shape[:last_axis]):\n        j_ion_coords[index] = alpha_rad\n\n    ret['j_ion_coords'] = j_ion_coords\n\n    return ret\n</code></pre>"},{"location":"reference/models/#hallmd.models.hallthruster_jl","title":"<code>hallthruster_jl(thruster_inputs=None, thruster='SPT-100', config=None, simulation=None, postprocess=None, model_fidelity=(2, 2), output_path=None, version=HALLTHRUSTER_VERSION_DEFAULT, pem_to_julia='default', fidelity_function='default', julia_script=None, run_kwargs='default', shock_threshold=None)</code>","text":"<p>Run a single <code>HallThruster.jl</code> simulation for a given set of inputs. This function will write a temporary input file to disk, call <code>HallThruster.run_simulation()</code> in Julia, and read the output file back into Python. Will return time-averaged performance metrics and ion velocity for use with the PEM.</p> <p>Note that the specific inputs and outputs described here can be configured using the <code>pem_to_julia</code> dict.</p> <p>Required configuration</p> <p>You must specify a thruster, a domain, a mass flow rate, and a discharge voltage to run the simulation. The thruster must be defined in the <code>hallmd.devices</code> directory or as a dictionary with the required fields. The mass flow rate and discharge voltage are specified in <code>thruster_inputs</code> as <code>mdot_a</code> (kg/s) and <code>V_a</code> (V), respectively. The domain is specified as a list <code>[left_bound, right_bound]</code> in the <code>config</code> dictionary. See the HallThruster.jl docs for more details.</p> PARAMETER DESCRIPTION <code>thruster_inputs</code> <p>named key-value pairs of thruster inputs: <code>P_b</code>, <code>V_a</code>, <code>mdot_a</code>, <code>T_e</code>, <code>u_n</code>, <code>l_t</code>, <code>a_1</code>, <code>a_2</code>, <code>delta_z</code>, <code>z0</code>, <code>p0</code>, and <code>V_cc</code> for background pressure (Torr), anode voltage, anode mass flow rate (kg/s), electron temperature (eV), neutral velocity (m/s), transition length (m), anomalous transport coefficients, and cathode coupling voltage. Will override the corresponding values in <code>config</code> if provided.</p> <p> TYPE: <code>Dataset</code> DEFAULT: <code>None</code> </p> <code>thruster</code> <p>the name of the thruster to simulate (must be importable from <code>hallmd.devices</code>, see <code>load_device</code>), or a dictionary that provides geometry and magnetic field information of the thruster to simulate; see the Hallthruster.jl docs. Will override <code>thruster</code> in <code>config</code> if provided. If None, will defer to <code>config</code>. Defaults to the SPT-100.</p> <p> TYPE: <code>Literal['SPT-100'] | str | dict</code> DEFAULT: <code>'SPT-100'</code> </p> <code>config</code> <p>dictionary of configs for <code>HallThruster.jl</code>, see the Hallthruster.jl docs for options and formatting.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>simulation</code> <p>dictionary of simulation parameters for <code>HallThruster.jl</code></p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>postprocess</code> <p>dictionary of post-processing parameters for <code>Hallthruster.jl</code></p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>model_fidelity</code> <p>tuple of integers that determine the number of cells and the number of charge states to use via <code>ncells = model_fidelity[0] * 50 + 100</code> and <code>ncharge = model_fidelity[1] + 1</code>. Will override <code>ncells</code> and <code>ncharge</code> in <code>simulation</code> and <code>config</code> if provided.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>(2, 2)</code> </p> <code>output_path</code> <p>base path to save output files, will write to current directory if not specified</p> <p> TYPE: <code>Optional[str | Path]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>version of HallThruster.jl to use; will search for a global <code>hallthruster_{version}</code> environment in the <code>~/.julia/environments/</code> directory. Can also specify a specific git ref (i.e. branch, commit hash, etc.) to use from GitHub. If the <code>hallthruster_{version}</code> environment does not exist, an error will be raised -- you should create this environment first before using it.</p> <p> TYPE: <code>str</code> DEFAULT: <code>HALLTHRUSTER_VERSION_DEFAULT</code> </p> <code>pem_to_julia</code> <p>a <code>dict</code> mapping of PEM shorthand variable names to a list of keys that maps into the <code>HallThruster.jl</code> input/output data structure. Defaults to the provided PEM_TO_JULIA dict defined in <code>hallmd.models.thruster</code>. For example, <code>{'P_b': ['config', 'background_pressure']}</code> will set <code>config['background_pressure'] = P_b</code>. If specified, will override and extend the default mapping.</p> <p> TYPE: <code>dict | str</code> DEFAULT: <code>'default'</code> </p> <code>fidelity_function</code> <p>a callable that takes a tuple of integers and returns a dictionary of simulation parameters. Defaults to <code>_default_model_fidelity</code> which sets <code>ncells</code> and <code>ncharge</code> based on the input tuple. The returned simulation parameters must be convertable to Julia via the <code>pem_to_julia</code> mapping. The callable should also take in the current json config dict.</p> <p> TYPE: <code>Callable[[tuple[int, ...]], dict]</code> DEFAULT: <code>'default'</code> </p> <code>julia_script</code> <p>path to a custom Julia script to run. The script should accept the input json file path as a command line argument. Defaults to just calling <code>HallThruster.run_simulation(input_file)</code>.</p> <p> TYPE: <code>Optional[str | Path]</code> DEFAULT: <code>None</code> </p> <code>run_kwargs</code> <p>additional keyword arguments to pass to <code>subprocess.run</code> when calling the Julia script. Defaults to <code>check=True</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>'default'</code> </p> <code>shock_threshold</code> <p>if provided, an error will be raised if the ion velocity reaches a maximum before this threshold axial location (in m) - used to detect and filter unwanted \"shock-like\" behavior, for example by providing a threshold of half the domain length. If not provided, then no filtering is performed (default).</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p><code>dict</code> of <code>Hallthruster.jl</code> outputs: <code>I_B0</code>, <code>I_d</code>, <code>T</code>, <code>eta_c</code>, <code>eta_m</code>, <code>eta_v</code>, and <code>u_ion</code> for ion beam current (A), discharge current (A), thrust (N), current efficiency, mass efficiency, voltage efficiency, and singly-charged ion velocity profile (m/s), all time-averaged.</p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def hallthruster_jl(\n    thruster_inputs: Dataset = None,\n    thruster: Literal[\"SPT-100\"] | str | dict = \"SPT-100\",\n    config: Optional[dict] = None,\n    simulation: Optional[dict] = None,\n    postprocess: Optional[dict] = None,\n    model_fidelity: tuple = (2, 2),\n    output_path: Optional[str | Path] = None,\n    version: str = HALLTHRUSTER_VERSION_DEFAULT,\n    pem_to_julia: dict | str = \"default\",\n    fidelity_function: Callable[[tuple[int, ...]], dict] = \"default\",\n    julia_script: Optional[str | Path] = None,\n    run_kwargs: dict = \"default\",\n    shock_threshold: float = None,\n) -&gt; Dataset:\n    \"\"\"Run a single `HallThruster.jl` simulation for a given set of inputs. This function will write a temporary\n    input file to disk, call `HallThruster.run_simulation()` in Julia, and read the output file back into Python. Will\n    return time-averaged performance metrics and ion velocity for use with the PEM.\n\n    Note that the specific inputs and outputs described here can be configured using the `pem_to_julia` dict.\n\n    !!! Warning \"Required configuration\"\n        You must specify a thruster, a domain, a mass flow rate, and a discharge voltage to run the simulation. The\n        thruster must be defined in the `hallmd.devices` directory or as a dictionary with the required fields.\n        The mass flow rate and discharge voltage are specified in `thruster_inputs` as `mdot_a` (kg/s) and\n        `V_a` (V), respectively. The domain is specified as a list `[left_bound, right_bound]` in the\n        `config` dictionary. See the\n        [HallThruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/reference/config/) for more details.\n\n    :param thruster_inputs: named key-value pairs of thruster inputs: `P_b`, `V_a`, `mdot_a`, `T_e`, `u_n`, `l_t`,\n                            `a_1`, `a_2`, `delta_z`, `z0`, `p0`, and `V_cc` for background pressure (Torr), anode\n                            voltage, anode mass flow rate (kg/s), electron temperature (eV), neutral velocity (m/s),\n                            transition length (m), anomalous transport coefficients, and cathode coupling voltage. Will\n                            override the corresponding values in `config` if provided.\n    :param thruster: the name of the thruster to simulate (must be importable from `hallmd.devices`, see\n                     [`load_device`][hallmd.utils.load_device]), or a dictionary that provides geometry and\n                     magnetic field information of the thruster to simulate; see the\n                     [Hallthruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/tutorials/simulation//run/).\n                     Will override `thruster` in `config` if provided. If None, will defer to `config`.\n                     Defaults to the SPT-100.\n    :param config: dictionary of configs for `HallThruster.jl`, see the\n                   [Hallthruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/reference/config/) for\n                   options and formatting.\n    :param simulation: dictionary of simulation parameters for `HallThruster.jl`\n    :param postprocess: dictionary of post-processing parameters for `Hallthruster.jl`\n    :param model_fidelity: tuple of integers that determine the number of cells and the number of charge states to use\n                           via `ncells = model_fidelity[0] * 50 + 100` and `ncharge = model_fidelity[1] + 1`.\n                           Will override `ncells` and `ncharge` in `simulation` and `config` if provided.\n    :param output_path: base path to save output files, will write to current directory if not specified\n    :param version: version of HallThruster.jl to use; will\n                    search for a global `hallthruster_{version}` environment in the `~/.julia/environments/` directory.\n                    Can also specify a specific git ref (i.e. branch, commit hash, etc.) to use from GitHub. If the\n                    `hallthruster_{version}` environment does not exist, an error will be raised -- you should create\n                    this environment first before using it.\n    :param pem_to_julia: a `dict` mapping of PEM shorthand variable names to a list of keys that maps into the\n                         `HallThruster.jl` input/output data structure. Defaults to the provided PEM_TO_JULIA dict\n                         defined in [`hallmd.models.thruster`][hallmd.models.thruster]. For example,\n                         `{'P_b': ['config', 'background_pressure']}` will set `config['background_pressure'] = P_b`.\n                         If specified, will override and extend the default mapping.\n    :param fidelity_function: a callable that takes a tuple of integers and returns a dictionary of simulation\n                              parameters. Defaults to `_default_model_fidelity` which sets `ncells` and `ncharge` based\n                              on the input tuple. The returned simulation parameters must be convertable to Julia via\n                              the `pem_to_julia` mapping. The callable should also take in the current json config dict.\n    :param julia_script: path to a custom Julia script to run. The script should accept the input json file path as\n                         a command line argument. Defaults to just calling `HallThruster.run_simulation(input_file)`.\n    :param run_kwargs: additional keyword arguments to pass to `subprocess.run` when calling the Julia script.\n                       Defaults to `check=True`.\n    :param shock_threshold: if provided, an error will be raised if the ion velocity reaches a maximum before this\n                            threshold axial location (in m) - used to detect and filter unwanted \"shock-like\" behavior,\n                            for example by providing a threshold of half the domain length. If not provided, then no\n                            filtering is performed (default).\n    :returns: `dict` of `Hallthruster.jl` outputs: `I_B0`, `I_d`, `T`, `eta_c`, `eta_m`, `eta_v`, and `u_ion` for ion\n              beam current (A), discharge current (A), thrust (N), current efficiency, mass efficiency, voltage\n              efficiency, and singly-charged ion velocity profile (m/s), all time-averaged.\n    \"\"\"\n    if pem_to_julia is None or pem_to_julia == \"default\":\n        pem_to_julia = copy.deepcopy(PEM_TO_JULIA)\n    else:\n        tmp = copy.deepcopy(PEM_TO_JULIA)\n        tmp.update(pem_to_julia)\n        pem_to_julia = tmp\n\n    thruster_inputs = thruster_inputs or {}\n\n    # Format PEM inputs for HallThruster.jl\n    json_data = _format_hallthruster_jl_input(\n        thruster_inputs,\n        thruster=thruster,\n        config=config,\n        simulation=simulation,\n        postprocess=postprocess,\n        model_fidelity=model_fidelity,\n        output_path=output_path,\n        pem_to_julia=pem_to_julia,\n        fidelity_function=fidelity_function,\n    )\n    # Get julia environment\n    jl_environment = get_jl_env(version) if version is not None else None\n\n    if run_kwargs is None:\n        run_kwargs = {}\n    elif run_kwargs == \"default\":\n        run_kwargs = {\"check\": True}\n\n    # Run Julia\n    t1 = time.time()\n    sim_results = run_hallthruster_jl(json_data, jl_env=jl_environment, jl_script=julia_script, **run_kwargs)\n    t2 = time.time()\n\n    # Format QOIs for PEM\n    thruster_outputs = _convert_to_pem(sim_results, pem_to_julia)\n\n    # Raise an exception if thrust or beam current are negative (non-physical cases)\n    thrust = thruster_outputs.get(\"T\", 0)\n    beam_current = thruster_outputs.get(\"I_B0\", 0)\n    if thrust &lt; 0 or beam_current &lt; 0:\n        raise ValueError(f\"Exception due to non-physical case: thrust={thrust} N, beam current={beam_current} A\")\n\n    # Raise an exception for ion velocity that exhibits \"shock\" behavior\n    if shock_threshold is not None:\n        z_coords = thruster_outputs.get(\"u_ion_coords\")\n        ion_velocity = thruster_outputs.get(\"u_ion\")\n        if z_coords is not None and ion_velocity is not None:\n            if (z_max := z_coords[np.argmax(ion_velocity)]) &lt; shock_threshold:\n                raise ValueError(f\"Exception due to shock-like behavior: max ion velocity occurs at z={z_max:.3f} m\")\n\n    thruster_outputs[\"model_cost\"] = t2 - t1  # seconds\n\n    if output_path is not None:\n        output_file = Path(json_data[\"postprocess\"].get(\"output_file\"))\n        thruster_outputs[\"output_path\"] = output_file.relative_to(Path(output_path).resolve()).as_posix()\n\n    return thruster_outputs\n</code></pre>"},{"location":"reference/models/cathode/","title":"cathode","text":""},{"location":"reference/models/cathode/#hallmd.models.cathode","title":"<code>hallmd.models.cathode</code>","text":"<p>Module for cathode models.</p> <p>Includes:</p> <ul> <li><code>cathode_coupling()</code> - cathode coupling model with pressure dependence (Jorns 2021)</li> </ul>"},{"location":"reference/models/cathode/#hallmd.models.cathode.cathode_coupling","title":"<code>cathode_coupling(inputs)</code>","text":"<p>Computes cathode coupling voltage dependence on background pressure.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>input arrays - <code>P_b</code>, <code>V_a</code>, <code>T_e</code>, <code>V_vac</code>, <code>Pstar</code>, <code>P_T</code> for background pressure (Torr), discharge voltage (V), electron temperature (eV), vacuum coupling voltage (V), and model parameters P* (Torr) and P_T (Torr).</p> <p> TYPE: <code>Dataset</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>output arrays - <code>V_cc</code> for cathode coupling voltage (V).</p> Source code in <code>src/hallmd/models/cathode.py</code> <pre><code>def cathode_coupling(inputs: Dataset) -&gt; Dataset:\n    \"\"\"Computes cathode coupling voltage dependence on background pressure.\n\n    :param inputs: input arrays - `P_b`, `V_a`, `T_e`, `V_vac`, `Pstar`, `P_T` for background pressure (Torr), discharge\n                   voltage (V), electron temperature (eV), vacuum coupling voltage (V), and model parameters P* (Torr)\n                   and P_T (Torr).\n    :returns outputs: output arrays - `V_cc` for cathode coupling voltage (V).\n    \"\"\"\n    # Load inputs\n    PB = inputs['P_b'] * TORR_2_PA          # Background Pressure (Torr)\n    Va = inputs['V_a']                      # Anode voltage (V)\n    Te = inputs['T_e']                      # Electron temperature at the cathode (eV)\n    V_vac = inputs['V_vac']                 # Vacuum coupling voltage model parameter (V)\n    Pstar = inputs['Pstar'] * TORR_2_PA     # Model parameter P* (Torr)\n    PT = inputs['P_T'] * TORR_2_PA          # Model parameter P_T (Torr)\n\n    # Compute cathode coupling voltage\n    V_cc = np.atleast_1d(V_vac + Te * np.log(1 + PB / PT) - (Te / (PT + Pstar)) * PB)\n    V_cc[V_cc &lt; 0] = 0\n    ind = np.where(V_cc &gt; Va)\n    V_cc[ind] = np.atleast_1d(Va)[ind]\n    return {'V_cc': V_cc}\n</code></pre>"},{"location":"reference/models/plume/","title":"plume","text":""},{"location":"reference/models/plume/#hallmd.models.plume","title":"<code>hallmd.models.plume</code>","text":"<p>Module for Hall thruster plume models.</p> <p>Includes:</p> <ul> <li><code>current_density()</code> - Semi-empirical ion current density model with \\(1/r^2\\) Gaussian beam.</li> </ul>"},{"location":"reference/models/plume/#hallmd.models.plume.current_density","title":"<code>current_density(inputs, sweep_radius=1.0)</code>","text":"<p>Compute the semi-empirical ion current density (\\(j_{ion}\\)) plume model over a 90 deg sweep, with 0 deg at thruster centerline. Also compute the plume divergence angle. Will return the ion current density at 91 points, from 0 to 90 deg in 1 deg increments. The angular locations are returned as <code>j_ion_coords</code> in radians.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>input arrays - <code>P_b</code>, <code>c0</code>, <code>c1</code>, <code>c2</code>, <code>c3</code>, <code>c4</code>, <code>c5</code>, <code>sigma_cex</code>, <code>I_B0</code> for background pressure (Torr), plume fit coefficients, charge-exchange cross-section (\\(m^2\\)), and total initial ion beam current (A). If <code>T</code> is provided, then also compute corrected thrust using the divergence angle.</p> <p> TYPE: <code>Dataset</code> </p> <code>sweep_radius</code> <p>the location(s) at which to compute the ion current density 90 deg sweep, in units of radial distance (m) from the thruster exit plane. If multiple locations are provided, then the returned \\(j_{ion}\\) array's last dimension will match the length of <code>sweep_radius</code>. Defaults to 1 meter.</p> <p> TYPE: <code>float | list</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <p>output arrays - <code>j_ion</code> for ion current density (\\(A/m^2\\)) at the <code>j_ion_coords</code> locations, and <code>div_angle</code> in radians for the divergence angle of the plume. Optionally, <code>T_c</code> for corrected thrust (N) if <code>T</code> is provided in the inputs.</p> Source code in <code>src/hallmd/models/plume.py</code> <pre><code>def current_density(inputs: Dataset, sweep_radius: float | list = 1.0):\n    \"\"\"Compute the semi-empirical ion current density ($j_{ion}$) plume model over a 90 deg sweep, with 0 deg at\n    thruster centerline. Also compute the plume divergence angle. Will return the ion current density at 91 points,\n    from 0 to 90 deg in 1 deg increments. The angular locations are returned as `j_ion_coords` in radians.\n\n    :param inputs: input arrays - `P_b`, `c0`, `c1`, `c2`, `c3`, `c4`, `c5`, `sigma_cex`, `I_B0` for background\n                   pressure (Torr), plume fit coefficients, charge-exchange cross-section ($m^2$),\n                   and total initial ion beam current (A). If `T` is provided, then\n                   also compute corrected thrust using the divergence angle.\n    :param sweep_radius: the location(s) at which to compute the ion current density 90 deg sweep, in units of radial\n                         distance (m) from the thruster exit plane. If multiple locations are provided, then the\n                         returned $j_{ion}$ array's last dimension will match the length of `sweep_radius`. Defaults to\n                         1 meter.\n    :returns outputs: output arrays - `j_ion` for ion current density ($A/m^2$) at the `j_ion_coords` locations,\n                                       and `div_angle` in radians for the divergence angle of the plume. Optionally,\n                                       `T_c` for corrected thrust (N) if `T` is provided in the inputs.\n    \"\"\"\n    # Load plume inputs\n    P_B = inputs['P_b'] * TORR_2_PA  # Background pressure (Torr)\n    c0 = inputs['c0']  # Fit coefficients (-)\n    c1 = inputs['c1']  # (-)\n    c2 = inputs['c2']  # (rad/Pa)\n    c3 = inputs['c3']  # (rad)\n    c4 = inputs['c4']  # (m^-3/Pa)\n    c5 = inputs['c5']  # (m^-3)\n    sigma_cex = inputs['sigma_cex']  # Charge-exchange cross-section (m^2)\n    I_B0 = inputs['I_B0']  # Total initial ion beam current (A)\n    thrust = inputs.get('T', None)  # Thrust (N)\n    sweep_radius = np.atleast_1d(sweep_radius)\n\n    # 90 deg angle sweep for ion current density\n    alpha_rad = np.linspace(0, np.pi / 2, 91)\n\n    # Neutral density\n    n = c4 * P_B + c5  # m^-3\n\n    # Divergence angles\n    alpha1 = np.atleast_1d(c2 * P_B + c3)  # Main beam divergence (rad)\n    alpha1[alpha1 &gt; np.pi / 2] = np.pi / 2\n    alpha2 = alpha1 / c1  # Scattered beam divergence (rad)\n\n    with np.errstate(invalid='ignore', divide='ignore'):\n        A1 = (1 - c0) / (\n            (np.pi ** (3 / 2))\n            / 2\n            * alpha1\n            * np.exp(-((alpha1 / 2) ** 2))\n            * (\n                2 * erfi(alpha1 / 2)\n                + erfi((np.pi * 1j - (alpha1**2)) / (2 * alpha1))\n                - erfi((np.pi * 1j + (alpha1**2)) / (2 * alpha1))\n            )\n        )\n        A2 = c0 / (\n            (np.pi ** (3 / 2))\n            / 2\n            * alpha2\n            * np.exp(-((alpha2 / 2) ** 2))\n            * (\n                2 * erfi(alpha2 / 2)\n                + erfi((np.pi * 1j - (alpha2**2)) / (2 * alpha2))\n                - erfi((np.pi * 1j + (alpha2**2)) / (2 * alpha2))\n            )\n        )\n        # Broadcast over angles and radii (..., a, r)\n        A1 = np.expand_dims(A1, axis=(-1, -2))  # (..., 1, 1)\n        A2 = np.expand_dims(A2, axis=(-1, -2))\n        alpha1 = np.expand_dims(alpha1, axis=(-1, -2))\n        alpha2 = np.expand_dims(alpha2, axis=(-1, -2))\n        I_B0 = np.expand_dims(I_B0, axis=(-1, -2))\n        n = np.expand_dims(n, axis=(-1, -2))\n        sigma_cex = np.expand_dims(sigma_cex, axis=(-1, -2))\n\n        decay = np.exp(-sweep_radius * n * sigma_cex)  # (..., 1, r)\n        j_cex = I_B0 * (1 - decay) / (2 * np.pi * sweep_radius**2)\n\n        base_density = I_B0 * decay / sweep_radius**2\n        j_beam = base_density * A1 * np.exp(-((alpha_rad[..., np.newaxis] / alpha1) ** 2))\n        j_scat = base_density * A2 * np.exp(-((alpha_rad[..., np.newaxis] / alpha2) ** 2))\n\n        j_ion = j_beam + j_scat + j_cex  # (..., 91, r) the current density 1d profile at r radial locations\n\n    # Set j~0 where alpha1 &lt; 0 (invalid cases)\n    invalid_idx = np.logical_or(np.any(alpha1 &lt;= 0, axis=(-1, -2)), np.any(j_ion &lt;= 0, axis=(-1, -2)))\n    j_ion[invalid_idx, ...] = 1e-20\n    j_cex[invalid_idx, ...] = 1e-20\n\n    if np.any(abs(j_ion.imag) &gt; 0):\n        LOGGER.warning('Predicted beam current has non-zero imaginary component.')\n    j_ion = j_ion.real\n\n    # Calculate divergence angle from https://aip.scitation.org/doi/10.1063/5.0066849\n    # Requires alpha = [0, ..., 90] deg, from thruster exit-plane to thruster centerline (need to flip)\n    # do j_beam + j_scat instead of j_ion - j_cex to avoid catastrophic loss of precision when\n    # j_beam and j_scat &lt;&lt; j_cex\n    j_non_cex = np.flip((j_beam + j_scat).real, axis=-2)\n    den_integrand = j_non_cex * np.cos(alpha_rad[..., np.newaxis])\n    num_integrand = den_integrand * np.sin(alpha_rad[..., np.newaxis])\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        num = simpson(num_integrand, x=alpha_rad, axis=-2)\n        den = simpson(den_integrand, x=alpha_rad, axis=-2)\n        cos_div = np.atleast_1d(num / den)\n        cos_div[cos_div == np.inf] = np.nan\n\n    div_angle = np.arccos(cos_div)  # Divergence angle (rad) - (..., r)\n\n    # Squeeze last dim if only a single radius was passed\n    if sweep_radius.shape[0] == 1:\n        j_ion = np.squeeze(j_ion, axis=-1)\n        div_angle = np.squeeze(div_angle, axis=-1)\n\n    ret = {'j_ion': j_ion, 'div_angle': div_angle}\n\n    if thrust is not None:\n        thrust_corrected = np.expand_dims(thrust, axis=-1) * cos_div\n        if sweep_radius.shape[0] == 1:\n            thrust_corrected = np.squeeze(thrust_corrected, axis=-1)\n        ret['T_c'] = thrust_corrected\n\n    # Interpolate to requested angles\n    # if j_ion_coords is not None:\n    #     # Extend to range (-90, 90) deg\n    #     alpha_grid = np.concatenate((-np.flip(alpha_rad)[:-1], alpha_rad))               # (2M-1,)\n    #     jion_grid = np.concatenate((np.flip(j_ion, axis=-1)[..., :-1], j_ion), axis=-1)  # (..., 2M-1)\n    #\n    #     f = interp1d(alpha_grid, jion_grid, axis=-1)\n    #     j_ion = f(j_ion_coords)  # (..., num_pts)\n\n    # Broadcast coords to same loop shape as j_ion (all use the same coords -- store in object array)\n    last_axis = -1 if sweep_radius.shape[0] == 1 else -2\n    j_ion_coords = np.empty(j_ion.shape[:last_axis], dtype=object)\n    for index in np.ndindex(j_ion.shape[:last_axis]):\n        j_ion_coords[index] = alpha_rad\n\n    ret['j_ion_coords'] = j_ion_coords\n\n    return ret\n</code></pre>"},{"location":"reference/models/thruster/","title":"thruster","text":""},{"location":"reference/models/thruster/#hallmd.models.thruster","title":"<code>hallmd.models.thruster</code>","text":"<p>Module for Hall thruster models.</p> <p>Note</p> <p>Only current implementation is for the 1d fluid Hallthruster.jl code. Other thruster codes can be implemented similarly here.</p> <p>Includes:</p> <ul> <li><code>run_hallthruster_jl</code> - General wrapper to run HallThruster.jl for a single set of inputs</li> <li><code>hallthruster_jl()</code> - PEM wrapper to run HallThruster.jl for a set of PEM inputs</li> <li><code>get_jl_env</code> - Get the path of the julia environment created for HallThruster.jl for a specific git ref</li> <li><code>PEM_TO_JULIA</code> - Mapping of PEM variable names to a path in the HallThruster.jl input/output structure (defaults)</li> </ul>"},{"location":"reference/models/thruster/#hallmd.models.thruster.get_jl_binary","title":"<code>get_jl_binary()</code>","text":"<p>use the juliaup config file to find out where the default julia binary is stored. if juliaup is not installed, returns 'julia'. this lets us avoid running juliaup's wrapper executable, which has led to concurrency issues. This is designed for use on the cluster, so on windows it just returns <code>julia</code>.</p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def get_jl_binary():\n    \"\"\"use the juliaup config file to find out where the default julia binary is stored.\n    if juliaup is not installed, returns 'julia'.\n    this lets us avoid running juliaup's wrapper executable, which has led to concurrency issues.\n    This is designed for use on the cluster, so on windows it just returns `julia`.\"\"\"\n\n    if platform.system() == \"Windows\":\n        return \"julia\"\n\n    home = os.environ[\"HOME\"]\n    juliaup_dir = Path(f\"{home}/.julia/juliaup\")\n    juliaup_json = juliaup_dir / \"juliaup.json\"\n    if not os.path.exists(juliaup_json):\n        return \"julia\"\n\n    with open(juliaup_json, \"r\") as fd:\n        jl_config = json.load(fd)\n\n    default = jl_config[\"Default\"]\n    versions = jl_config[\"InstalledVersions\"]\n    channels = jl_config[\"InstalledChannels\"]\n\n    version = versions[channels[default][\"Version\"]]\n    path = juliaup_dir / version[\"Path\"] / \"bin\" / \"julia\"\n    return path\n</code></pre>"},{"location":"reference/models/thruster/#hallmd.models.thruster.get_jl_env","title":"<code>get_jl_env(git_ref)</code>","text":"<p>Get the path of the julia environment created for HallThruster.jl for a specific git ref.</p> PARAMETER DESCRIPTION <code>git_ref</code> <p>The git ref (i.e. commit hash, version tag, branch, etc.) of HallThruster.jl to use.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def get_jl_env(git_ref: str) -&gt; Path:\n    \"\"\"Get the path of the julia environment created for HallThruster.jl for a specific git ref.\n\n    :param git_ref: The git ref (i.e. commit hash, version tag, branch, etc.) of HallThruster.jl to use.\n    \"\"\"\n    global_env_dir = Path(\"~/.julia/environments/\").expanduser()\n    env_path = global_env_dir / f\"hallthruster_{git_ref}\"\n    return env_path\n</code></pre>"},{"location":"reference/models/thruster/#hallmd.models.thruster.hallthruster_jl","title":"<code>hallthruster_jl(thruster_inputs=None, thruster='SPT-100', config=None, simulation=None, postprocess=None, model_fidelity=(2, 2), output_path=None, version=HALLTHRUSTER_VERSION_DEFAULT, pem_to_julia='default', fidelity_function='default', julia_script=None, run_kwargs='default', shock_threshold=None)</code>","text":"<p>Run a single <code>HallThruster.jl</code> simulation for a given set of inputs. This function will write a temporary input file to disk, call <code>HallThruster.run_simulation()</code> in Julia, and read the output file back into Python. Will return time-averaged performance metrics and ion velocity for use with the PEM.</p> <p>Note that the specific inputs and outputs described here can be configured using the <code>pem_to_julia</code> dict.</p> <p>Required configuration</p> <p>You must specify a thruster, a domain, a mass flow rate, and a discharge voltage to run the simulation. The thruster must be defined in the <code>hallmd.devices</code> directory or as a dictionary with the required fields. The mass flow rate and discharge voltage are specified in <code>thruster_inputs</code> as <code>mdot_a</code> (kg/s) and <code>V_a</code> (V), respectively. The domain is specified as a list <code>[left_bound, right_bound]</code> in the <code>config</code> dictionary. See the HallThruster.jl docs for more details.</p> PARAMETER DESCRIPTION <code>thruster_inputs</code> <p>named key-value pairs of thruster inputs: <code>P_b</code>, <code>V_a</code>, <code>mdot_a</code>, <code>T_e</code>, <code>u_n</code>, <code>l_t</code>, <code>a_1</code>, <code>a_2</code>, <code>delta_z</code>, <code>z0</code>, <code>p0</code>, and <code>V_cc</code> for background pressure (Torr), anode voltage, anode mass flow rate (kg/s), electron temperature (eV), neutral velocity (m/s), transition length (m), anomalous transport coefficients, and cathode coupling voltage. Will override the corresponding values in <code>config</code> if provided.</p> <p> TYPE: <code>Dataset</code> DEFAULT: <code>None</code> </p> <code>thruster</code> <p>the name of the thruster to simulate (must be importable from <code>hallmd.devices</code>, see <code>load_device</code>), or a dictionary that provides geometry and magnetic field information of the thruster to simulate; see the Hallthruster.jl docs. Will override <code>thruster</code> in <code>config</code> if provided. If None, will defer to <code>config</code>. Defaults to the SPT-100.</p> <p> TYPE: <code>Literal['SPT-100'] | str | dict</code> DEFAULT: <code>'SPT-100'</code> </p> <code>config</code> <p>dictionary of configs for <code>HallThruster.jl</code>, see the Hallthruster.jl docs for options and formatting.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>simulation</code> <p>dictionary of simulation parameters for <code>HallThruster.jl</code></p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>postprocess</code> <p>dictionary of post-processing parameters for <code>Hallthruster.jl</code></p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>model_fidelity</code> <p>tuple of integers that determine the number of cells and the number of charge states to use via <code>ncells = model_fidelity[0] * 50 + 100</code> and <code>ncharge = model_fidelity[1] + 1</code>. Will override <code>ncells</code> and <code>ncharge</code> in <code>simulation</code> and <code>config</code> if provided.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>(2, 2)</code> </p> <code>output_path</code> <p>base path to save output files, will write to current directory if not specified</p> <p> TYPE: <code>Optional[str | Path]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>version of HallThruster.jl to use; will search for a global <code>hallthruster_{version}</code> environment in the <code>~/.julia/environments/</code> directory. Can also specify a specific git ref (i.e. branch, commit hash, etc.) to use from GitHub. If the <code>hallthruster_{version}</code> environment does not exist, an error will be raised -- you should create this environment first before using it.</p> <p> TYPE: <code>str</code> DEFAULT: <code>HALLTHRUSTER_VERSION_DEFAULT</code> </p> <code>pem_to_julia</code> <p>a <code>dict</code> mapping of PEM shorthand variable names to a list of keys that maps into the <code>HallThruster.jl</code> input/output data structure. Defaults to the provided PEM_TO_JULIA dict defined in <code>hallmd.models.thruster</code>. For example, <code>{'P_b': ['config', 'background_pressure']}</code> will set <code>config['background_pressure'] = P_b</code>. If specified, will override and extend the default mapping.</p> <p> TYPE: <code>dict | str</code> DEFAULT: <code>'default'</code> </p> <code>fidelity_function</code> <p>a callable that takes a tuple of integers and returns a dictionary of simulation parameters. Defaults to <code>_default_model_fidelity</code> which sets <code>ncells</code> and <code>ncharge</code> based on the input tuple. The returned simulation parameters must be convertable to Julia via the <code>pem_to_julia</code> mapping. The callable should also take in the current json config dict.</p> <p> TYPE: <code>Callable[[tuple[int, ...]], dict]</code> DEFAULT: <code>'default'</code> </p> <code>julia_script</code> <p>path to a custom Julia script to run. The script should accept the input json file path as a command line argument. Defaults to just calling <code>HallThruster.run_simulation(input_file)</code>.</p> <p> TYPE: <code>Optional[str | Path]</code> DEFAULT: <code>None</code> </p> <code>run_kwargs</code> <p>additional keyword arguments to pass to <code>subprocess.run</code> when calling the Julia script. Defaults to <code>check=True</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>'default'</code> </p> <code>shock_threshold</code> <p>if provided, an error will be raised if the ion velocity reaches a maximum before this threshold axial location (in m) - used to detect and filter unwanted \"shock-like\" behavior, for example by providing a threshold of half the domain length. If not provided, then no filtering is performed (default).</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p><code>dict</code> of <code>Hallthruster.jl</code> outputs: <code>I_B0</code>, <code>I_d</code>, <code>T</code>, <code>eta_c</code>, <code>eta_m</code>, <code>eta_v</code>, and <code>u_ion</code> for ion beam current (A), discharge current (A), thrust (N), current efficiency, mass efficiency, voltage efficiency, and singly-charged ion velocity profile (m/s), all time-averaged.</p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def hallthruster_jl(\n    thruster_inputs: Dataset = None,\n    thruster: Literal[\"SPT-100\"] | str | dict = \"SPT-100\",\n    config: Optional[dict] = None,\n    simulation: Optional[dict] = None,\n    postprocess: Optional[dict] = None,\n    model_fidelity: tuple = (2, 2),\n    output_path: Optional[str | Path] = None,\n    version: str = HALLTHRUSTER_VERSION_DEFAULT,\n    pem_to_julia: dict | str = \"default\",\n    fidelity_function: Callable[[tuple[int, ...]], dict] = \"default\",\n    julia_script: Optional[str | Path] = None,\n    run_kwargs: dict = \"default\",\n    shock_threshold: float = None,\n) -&gt; Dataset:\n    \"\"\"Run a single `HallThruster.jl` simulation for a given set of inputs. This function will write a temporary\n    input file to disk, call `HallThruster.run_simulation()` in Julia, and read the output file back into Python. Will\n    return time-averaged performance metrics and ion velocity for use with the PEM.\n\n    Note that the specific inputs and outputs described here can be configured using the `pem_to_julia` dict.\n\n    !!! Warning \"Required configuration\"\n        You must specify a thruster, a domain, a mass flow rate, and a discharge voltage to run the simulation. The\n        thruster must be defined in the `hallmd.devices` directory or as a dictionary with the required fields.\n        The mass flow rate and discharge voltage are specified in `thruster_inputs` as `mdot_a` (kg/s) and\n        `V_a` (V), respectively. The domain is specified as a list `[left_bound, right_bound]` in the\n        `config` dictionary. See the\n        [HallThruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/reference/config/) for more details.\n\n    :param thruster_inputs: named key-value pairs of thruster inputs: `P_b`, `V_a`, `mdot_a`, `T_e`, `u_n`, `l_t`,\n                            `a_1`, `a_2`, `delta_z`, `z0`, `p0`, and `V_cc` for background pressure (Torr), anode\n                            voltage, anode mass flow rate (kg/s), electron temperature (eV), neutral velocity (m/s),\n                            transition length (m), anomalous transport coefficients, and cathode coupling voltage. Will\n                            override the corresponding values in `config` if provided.\n    :param thruster: the name of the thruster to simulate (must be importable from `hallmd.devices`, see\n                     [`load_device`][hallmd.utils.load_device]), or a dictionary that provides geometry and\n                     magnetic field information of the thruster to simulate; see the\n                     [Hallthruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/tutorials/simulation//run/).\n                     Will override `thruster` in `config` if provided. If None, will defer to `config`.\n                     Defaults to the SPT-100.\n    :param config: dictionary of configs for `HallThruster.jl`, see the\n                   [Hallthruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/reference/config/) for\n                   options and formatting.\n    :param simulation: dictionary of simulation parameters for `HallThruster.jl`\n    :param postprocess: dictionary of post-processing parameters for `Hallthruster.jl`\n    :param model_fidelity: tuple of integers that determine the number of cells and the number of charge states to use\n                           via `ncells = model_fidelity[0] * 50 + 100` and `ncharge = model_fidelity[1] + 1`.\n                           Will override `ncells` and `ncharge` in `simulation` and `config` if provided.\n    :param output_path: base path to save output files, will write to current directory if not specified\n    :param version: version of HallThruster.jl to use; will\n                    search for a global `hallthruster_{version}` environment in the `~/.julia/environments/` directory.\n                    Can also specify a specific git ref (i.e. branch, commit hash, etc.) to use from GitHub. If the\n                    `hallthruster_{version}` environment does not exist, an error will be raised -- you should create\n                    this environment first before using it.\n    :param pem_to_julia: a `dict` mapping of PEM shorthand variable names to a list of keys that maps into the\n                         `HallThruster.jl` input/output data structure. Defaults to the provided PEM_TO_JULIA dict\n                         defined in [`hallmd.models.thruster`][hallmd.models.thruster]. For example,\n                         `{'P_b': ['config', 'background_pressure']}` will set `config['background_pressure'] = P_b`.\n                         If specified, will override and extend the default mapping.\n    :param fidelity_function: a callable that takes a tuple of integers and returns a dictionary of simulation\n                              parameters. Defaults to `_default_model_fidelity` which sets `ncells` and `ncharge` based\n                              on the input tuple. The returned simulation parameters must be convertable to Julia via\n                              the `pem_to_julia` mapping. The callable should also take in the current json config dict.\n    :param julia_script: path to a custom Julia script to run. The script should accept the input json file path as\n                         a command line argument. Defaults to just calling `HallThruster.run_simulation(input_file)`.\n    :param run_kwargs: additional keyword arguments to pass to `subprocess.run` when calling the Julia script.\n                       Defaults to `check=True`.\n    :param shock_threshold: if provided, an error will be raised if the ion velocity reaches a maximum before this\n                            threshold axial location (in m) - used to detect and filter unwanted \"shock-like\" behavior,\n                            for example by providing a threshold of half the domain length. If not provided, then no\n                            filtering is performed (default).\n    :returns: `dict` of `Hallthruster.jl` outputs: `I_B0`, `I_d`, `T`, `eta_c`, `eta_m`, `eta_v`, and `u_ion` for ion\n              beam current (A), discharge current (A), thrust (N), current efficiency, mass efficiency, voltage\n              efficiency, and singly-charged ion velocity profile (m/s), all time-averaged.\n    \"\"\"\n    if pem_to_julia is None or pem_to_julia == \"default\":\n        pem_to_julia = copy.deepcopy(PEM_TO_JULIA)\n    else:\n        tmp = copy.deepcopy(PEM_TO_JULIA)\n        tmp.update(pem_to_julia)\n        pem_to_julia = tmp\n\n    thruster_inputs = thruster_inputs or {}\n\n    # Format PEM inputs for HallThruster.jl\n    json_data = _format_hallthruster_jl_input(\n        thruster_inputs,\n        thruster=thruster,\n        config=config,\n        simulation=simulation,\n        postprocess=postprocess,\n        model_fidelity=model_fidelity,\n        output_path=output_path,\n        pem_to_julia=pem_to_julia,\n        fidelity_function=fidelity_function,\n    )\n    # Get julia environment\n    jl_environment = get_jl_env(version) if version is not None else None\n\n    if run_kwargs is None:\n        run_kwargs = {}\n    elif run_kwargs == \"default\":\n        run_kwargs = {\"check\": True}\n\n    # Run Julia\n    t1 = time.time()\n    sim_results = run_hallthruster_jl(json_data, jl_env=jl_environment, jl_script=julia_script, **run_kwargs)\n    t2 = time.time()\n\n    # Format QOIs for PEM\n    thruster_outputs = _convert_to_pem(sim_results, pem_to_julia)\n\n    # Raise an exception if thrust or beam current are negative (non-physical cases)\n    thrust = thruster_outputs.get(\"T\", 0)\n    beam_current = thruster_outputs.get(\"I_B0\", 0)\n    if thrust &lt; 0 or beam_current &lt; 0:\n        raise ValueError(f\"Exception due to non-physical case: thrust={thrust} N, beam current={beam_current} A\")\n\n    # Raise an exception for ion velocity that exhibits \"shock\" behavior\n    if shock_threshold is not None:\n        z_coords = thruster_outputs.get(\"u_ion_coords\")\n        ion_velocity = thruster_outputs.get(\"u_ion\")\n        if z_coords is not None and ion_velocity is not None:\n            if (z_max := z_coords[np.argmax(ion_velocity)]) &lt; shock_threshold:\n                raise ValueError(f\"Exception due to shock-like behavior: max ion velocity occurs at z={z_max:.3f} m\")\n\n    thruster_outputs[\"model_cost\"] = t2 - t1  # seconds\n\n    if output_path is not None:\n        output_file = Path(json_data[\"postprocess\"].get(\"output_file\"))\n        thruster_outputs[\"output_path\"] = output_file.relative_to(Path(output_path).resolve()).as_posix()\n\n    return thruster_outputs\n</code></pre>"},{"location":"reference/models/thruster/#hallmd.models.thruster.run_hallthruster_jl","title":"<code>run_hallthruster_jl(json_input, jl_env=None, jl_script=None, **kwargs)</code>","text":"<p>Python wrapper for <code>HallThruster.run_simulation(json_input)</code> in Julia.</p> PARAMETER DESCRIPTION <code>json_input</code> <p>either a dictionary containing <code>config</code>, <code>simulation</code>, and <code>postprocess</code> options for HallThruster.jl, or a string/Path containing a path to a JSON file with those inputs.</p> <p> TYPE: <code>dict | str | Path</code> </p> <code>jl_env</code> <p>The julia environment containing HallThruster.jl. Defaults to global Julia environment.</p> <p> TYPE: <code>Optional[str | Path]</code> DEFAULT: <code>None</code> </p> <code>jl_script</code> <p>path to a custom Julia script to run. The script should accept the input json file path as a command line argument. Defaults to just calling <code>HallThruster.run_simulation(input_file)</code>.</p> <p> TYPE: <code>Optional[str | Path]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>additional keyword arguments to pass to <code>subprocess.run</code> when calling the Julia script.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>dict</code> <p><code>dict</code> of <code>Hallthruster.jl</code> outputs. The specific outputs depend on the settings provided in the <code>postprocess</code> dict in the input. If <code>postprocess['output_file']</code> is present, this function will also write the requested outputs and restart information to that file.</p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def run_hallthruster_jl(\n    json_input: dict | str | Path, jl_env: Optional[str | Path] = None, jl_script: Optional[str | Path] = None, **kwargs\n) -&gt; dict:\n    \"\"\"Python wrapper for `HallThruster.run_simulation(json_input)` in Julia.\n\n    :param json_input: either a dictionary containing `config`, `simulation`, and `postprocess` options for\n            HallThruster.jl, or a string/Path containing a path to a JSON file with those inputs.\n    :param jl_env: The julia environment containing HallThruster.jl. Defaults to global Julia environment.\n    :param jl_script: path to a custom Julia script to run. The script should accept the input json file path as\n                      a command line argument. Defaults to just calling `HallThruster.run_simulation(input_file)`.\n    :param kwargs: additional keyword arguments to pass to `subprocess.run` when calling the Julia script.\n\n    :returns: `dict` of `Hallthruster.jl` outputs. The specific outputs depend on the settings\n              provided in the `postprocess` dict in the input. If `postprocess['output_file']` is present,\n              this function will also write the requested outputs and restart information to that file.\n    \"\"\"\n    # Read JSON input from file if path provided\n    if isinstance(json_input, str | Path):\n        with open(json_input, \"r\") as fp:\n            json_input: dict = json.load(fp)\n\n    tempfile_args = dict(suffix=\".json\", prefix=\"hallthruster_jl_\", mode=\"w\", delete=False, encoding=\"utf-8\")\n\n    # Get output file path. If one not provided, create a temporary\n    temp_out = False\n    if \"output_file\" in json_input.get(\"postprocess\", {}):\n        output_file = Path(json_input[\"postprocess\"].get(\"output_file\"))\n    elif \"output_file\" in json_input.get(\"input\", {}).get(\"postprocess\", {}):\n        output_file = Path(json_input[\"input\"][\"postprocess\"].get(\"output_file\"))\n    else:\n        temp_out = True\n        fd_out = tempfile.NamedTemporaryFile(**tempfile_args)\n        output_file = Path(fd_out.name)\n        fd_out.close()\n\n        if json_input.get(\"input\"):\n            json_input[\"input\"].setdefault(\"postprocess\", {})\n            json_input[\"input\"][\"postprocess\"][\"output_file\"] = str(output_file.resolve())\n        else:\n            json_input.setdefault(\"postprocess\", {})\n            json_input[\"postprocess\"][\"output_file\"] = str(output_file.resolve())\n\n    # Dump input to temporary file\n    fd = tempfile.NamedTemporaryFile(**tempfile_args)\n    input_file = fd.name\n    json.dump(json_input, fd, ensure_ascii=False, indent=4)\n    fd.close()\n\n    # Run HallThruster.jl on input file\n    if jl_script is None:\n        cmd = [\n            JL_BINARY,\n            \"--startup-file=no\",\n            \"-e\",\n            f'using HallThruster; HallThruster.run_simulation(raw\"{input_file}\")',\n        ]\n    else:\n        cmd = [JL_BINARY, \"--startup-file=no\", \"--\", str(Path(jl_script).resolve()), input_file]\n\n    if jl_env is not None:\n        if Path(jl_env).exists():\n            cmd.insert(1, f\"--project={Path(jl_env).resolve()}\")\n        else:\n            raise ValueError(\n                f\"Could not find Julia environment {jl_env}. Please create it first. \"\n                f\"See https://github.com/JANUS-Institute/HallThrusterPEM/blob/main/scripts/install_hallthruster.py\"\n            )\n\n    try:\n        subprocess.run(cmd, **kwargs)\n    finally:\n        # Delete temporary input file\n        os.unlink(input_file)\n\n    # Load output data\n    with open(output_file, \"r\") as fp:\n        output_data = json.load(fp)\n\n    if temp_out:\n        os.unlink(output_file)\n        if d := output_data.get(\"postprocess\"):\n            if \"output_file\" in d:\n                del d[\"output_file\"]\n        if d := output_data.get(\"input\"):\n            if d2 := d.get(\"postprocess\"):\n                if \"output_file\" in d2:\n                    del d2[\"output_file\"]\n\n    return output_data\n</code></pre>"},{"location":"theory/summary/","title":"Summary","text":"<p>The overarching goal of this software package is summarized by the abstract:</p> <p>We study the analysis and refinement of a predictive engineering model for enabling rapid prediction of Hall thruster system performance across a range of operating and environmental conditions and epistemic and aleatoric uncertainties. In particular, we describe an approach by which experimentally-observed facility effects are assimilated into the model, with a specific focus on facility background pressure. We propose a multifidelity, multidisciplinary approach for Bayesian calibration of an integrated system comprised of a set of component models. Furthermore, we perform uncertainty quantification over the calibrated model to assess the effects of epistemic and aleatoric uncertainty. This approach is realized on a coupled system of cathode, thruster, and plume models that predicts global quantities of interest (QoIs) such as thrust, efficiency, and discharge current as a function of operating conditions such as discharge voltage, mass flow rate, and background chamber pressure. As part of the calibration and prediction, we propose a number of metrics for assessing predictive model quality. Based on these metrics, we found that our proposed framework produces a calibrated model that is more accurate, sometimes by an order of magnitude, than engineering models using nominal parameters found in the literature. We also found for many QoIs that the remaining uncertainty was not sufficient to account for discrepancy with experimental data, and that existing models for facility effects do not sufficiently capture experimental trends. Finally, we confirmed through a global sensitivity analysis the prior intuition that anomalous transport dominates model uncertainty, and we conclude by suggesting several paths for future model improvement. We envision that the proposed metrics and procedures can guide the refinement of future model development activities.</p> <ul> <li>Eckels et al 2024</li> </ul> <p>Our first iteration of this framework comes in the form of the three-component feedforward system illustrated below:</p> <p></p> <p>Fig 1. The three-component feedforward Hall thruster model (Eckels et al 2024).</p> <p>This software package provides the testbench for rapid iteration and improvement of Hall thruster models in this multidisciplinary framework. Please see the scripts folder for our current progress. Please see the journal paper for specific details on the theory and background of the models and methods.</p>"}]}