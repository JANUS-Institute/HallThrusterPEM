{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-hallmd","title":"Contributing to <code>hallmd</code>","text":"<p>You might be here if you want to:</p> <ul> <li>Report a bug</li> <li>Discuss the current state of the code</li> <li>Submit a fix</li> <li>Propose a new feature</li> <li>Write unit tests</li> <li>Add to the documentation</li> </ul> <p>We use Github to host code and documentation, to track issues and feature requests, and to accept pull requests.</p>"},{"location":"contributing/#submitting-pull-requests","title":"Submitting pull requests","text":"<p>Pull requests are the best way to propose changes to the codebase (bug fixes, new features, docs, etc.)</p> <ol> <li>Fork the repo and create a branch from <code>main</code>.</li> <li>If you are adding a feature or making major changes, first create the issue in Github.</li> <li>If you've added code that should be tested, add to <code>/tests</code>.</li> <li>If you've made major changes, update the <code>/docs</code>.</li> <li>Ensure the test suite passes (<code>pdm run test</code>).</li> <li>Follow Conventional commits guidelines when adding a commit message.</li> <li>Ensure all <code>pre-commit</code> checks pass. Pro tip: use <code>pdm lint</code> to help.</li> <li>Issue the pull request!</li> </ol> <p>Use pdm to set up your development environment. An example contribution workflow is shown here:</p> <pre><code>git clone https://github.com/JANUS-Institute/HallThrusterPEM.git\ncd HallThrusterPEM\npdm install\ngit checkout -b &lt;your-branch-name&gt;\n\n# Make local changes\n\npdm run test  # make sure tests pass\ngit add -A\ngit commit -m \"fix: adding a bugfix\"\ngit push -u origin &lt;your-branch-name&gt;\n\n# Go to Github and \"Compare &amp; Pull Request\" on your branch\n# For your PR to be merged:\n  # squash all your commits on your branch (interactively in an IDE most likely)\n  # rebase to the top of origin/main to include new changes from others\n\ngit fetch\ngit rebase -i main your-branch  # for example\n\n# Resolve any conflicts\n# Your history now looks something like this:\n#              o your-branch\n#             /\n# ---o---o---o main\n\n# You can delete the branch when your PR has been merged\n</code></pre> <p>You can also find a good tutorial here.</p>"},{"location":"contributing/#report-bugs-using-issues","title":"Report bugs using issues","text":"<p>Open a new issue and describe your problem using the template. Provide screenshots where possible and example log files. Add labels to help categorize and describe your issue.</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the GPL-3.0 license.</p>"},{"location":"coverage/","title":"Coverage report","text":""},{"location":"examples/","title":"Examples","text":"<p>Coming soon. Short examples to showcase the usage/features.</p>"},{"location":"examples/#spt-100-data","title":"SPT-100 data","text":"<p>Load and plot SPT-100 experimental data.</p>"},{"location":"examples/#simple-model-configuration","title":"Simple model configuration","text":"<p>Show a simple <code>amisc</code> example and its config file.</p>"},{"location":"examples/#hallthrusterjl-configuration","title":"HallThruster.jl configuration","text":"<p>Repeat, but with the built-in HallThruster.jl model.</p>"},{"location":"examples/#monte-carlo","title":"Monte Carlo","text":"<p>Show a simple UQ plot (i.e. sample, predict, plot)</p>"},{"location":"examples/#model-calibration","title":"Model calibration","text":"<p>Show a simple run of least-squares or MCMC with plots.</p>"},{"location":"start/","title":"Getting started","text":"<p>Prototype of a predictive engineering model (PEM) of a Hall thruster. Integrates sub-models from multiple disciplines to simulate a Hall thruster operating in a vacuum chamber. Uses uncertainty quantification techniques to extrapolate model predictions to a space-like environment.</p>"},{"location":"start/#installation","title":"\u2699\ufe0f Installation","text":"<p>Ensure you are using Python 3.11 or later. You can install using pdm: <pre><code>pip install --user pdm\ngit clone https://github.com/JANUS-Institute/HallThrusterPEM.git  # or download the source from releases\ncd HallThrusterPEM\npdm install --prod\n</code></pre></p> <p><code>hallmd</code> uses the <code>HallThruster.jl</code> Julia package. Please see their docs for setting up Julia and installing. Alternatively, you may run the provided install script, which will install both Julia and <code>HallThruster.jl</code>.</p> <p>Assuming <code>python</code> is available on your path:</p> Linux/MacWindows <pre><code>curl -sSL https://raw.githubusercontent.com/JANUS-Institute/HallThrusterPEM/refs/heads/main/scripts/install_hallthruster.py | python -\n</code></pre> <pre><code>powershell -c \"Invoke-WebRequest -Uri https://raw.githubusercontent.com/JANUS-Institute/HallThrusterPEM/refs/heads/main/scripts/install_hallthruster.py | python -\"\n</code></pre>"},{"location":"start/#quickstart","title":"\ud83d\udccd Quickstart","text":"<pre><code>import matplotlib.pyplot as plt\n\nfrom hallmd.models import hallthruster_jl\n\n\nconfig = {\n    'discharge_voltage': 300,\n    'anode_mass_flow_rate': 5e-6,\n    'background_pressure_Torr': 1e-5,\n    'propellant': 'Xenon',\n    'domain': [0, 0.08]\n}\n\noutputs = hallthruster_jl(thruster='SPT-100', config=config)\n\nion_velocity = outputs['u_ion']\ngrid = outputs['u_ion_coords']\n\nfig, ax = plt.subplots()\nax.plot(grid, ion_velocity)\nax.set_xlabel('Axial location (m)')\nax.set_ylabel('Ion velocity (m/s)')\nplt.show()\n</code></pre>"},{"location":"start/#project-structure","title":"\ud83d\uddc2\ufe0f Project structure","text":"<pre><code>\ud83d\udcc1 HallThrusterPEM\n\u251c\u2500\u2500 \ud83d\udcc1 docs/\n\u251c\u2500\u2500 \ud83d\udcc1 scripts/           # Scripts for building predictive engineering models (PEMs)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 pem_v0/        # PEM v0 coupling of cathode -&gt; thruster -&gt; plume\n\u251c\u2500\u2500 \ud83d\udcc1 src/hallmd         # Python package source code root\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 models/        # Python wrappers for sub-models\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 data/          # Experimental data\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 devices/       # Device information (thrusters, equipment, etc.)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 utils.py       # Utility functions\n\u251c\u2500\u2500 \ud83d\udcc1 tests/             # Testing for Python package\n\u2514\u2500\u2500 \ud83d\udcc4 pdm.lock           # Frozen dependencies file\n</code></pre> <p>For more info on building PEMs with <code>hallmd</code>, see the scripts.</p>"},{"location":"start/#contributing","title":"\ud83c\udfd7\ufe0f Contributing","text":"<p>See the contribution guidelines.</p>"},{"location":"start/#reference","title":"\ud83d\udcd6 Reference","text":"<p>[1] Eckels, J. et al., \"Hall thruster model improvement by multidisciplinary uncertainty quantification,\" Journal of Electric Propulsion, vol 3, no 19, September 2024.</p> <p><sup><sub>Made with the copier-numpy template.</sub></sup></p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Coming soon (would be good to do this in a jupyter notebook).</p>"},{"location":"tutorial/#setup","title":"Setup","text":"<ul> <li>Installation, Julia environments, changing HallThruster.jl versions</li> </ul>"},{"location":"tutorial/#using-the-models","title":"Using the models","text":"<ul> <li>Built-in cathode, thruster, plume models</li> </ul>"},{"location":"tutorial/#linking-models","title":"Linking models","text":"<ul> <li>First do a \"manual\" passing of info between models</li> <li>Then show an amisc config.yml file (more info in amisc docs)</li> </ul>"},{"location":"tutorial/#loading-data","title":"Loading data","text":"<ul> <li>Show how to access experimental data</li> </ul>"},{"location":"tutorial/#advanced-features","title":"Advanced features","text":"<ul> <li>Surrogate and UQ analysis (see how-to guides for details, just give a taste here)</li> <li>Model calibration</li> </ul>"},{"location":"guides/calibrate/","title":"Calibrate a model","text":"<p>Coming soon. Walkthrough of MCMC calibration and the likelihood. Requires running a model and loading experimental data.</p>"},{"location":"guides/data/","title":"Load experimental data","text":"<p>Coming soon.</p>"},{"location":"guides/model/","title":"Run a Hall thruster model","text":"<p>Coming soon. Include config file setup, model linking, and <code>system.predict()</code>. Use <code>scripts/pem_v0</code> as an example.</p>"},{"location":"guides/surrogate/","title":"Build a surrogate","text":"<p>Coming soon. Uses the <code>amisc</code> surrogate framework and the <code>scripts/train.sh</code> script.</p>"},{"location":"guides/validate/","title":"Validate a model","text":"<p>Coming soon. Last step of comparing model to data and determining goodness-of-fit.</p>"},{"location":"reference/","title":"<code>hallmd</code>","text":"<p>Prototype of a predictive engineering model (PEM) of a Hall thruster. Integrates sub-models from multiple disciplines to simulate a Hall thruster operating in a vacuum chamber. Uses uncertainty quantification techniques to extrapolate model predictions to a space-like environment.</p> <ul> <li>Authors - Joshua Eckels (eckelsjd@umich.edu), Thomas Marks, Madison Allen, Declan Brick, Benjamin Jorns, Alex Gorodetsky</li> <li>License - GPL-3.0</li> </ul> <p>The <code>hallmd</code> package contains three sub-packages:</p> <ul> <li><code>models</code> - Contains the sub-models for each discipline in the Hall thruster system.</li> <li><code>devices</code> - Contains information about specific devices (thrusters and other equipment).</li> <li><code>data</code> - Contains experimental data for validating the models.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> hallmd</li> <li> data<ul> <li> spt100<ul> <li> diamant2014</li> <li> macdonald2019</li> <li> sankovic1993</li> </ul> </li> </ul> </li> <li> devices</li> <li> models<ul> <li> cathode</li> <li> plume</li> <li> thruster</li> </ul> </li> <li> utils</li> </ul>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#hallmd.utils","title":"<code>hallmd.utils</code>","text":"<p>Module to provide utilities for the <code>hallmd</code> package.</p> <p>Includes:</p> <ul> <li><code>load_device()</code> - Load a device configuration from the <code>hallmd.devices</code> directory.</li> </ul>"},{"location":"reference/utils/#hallmd.utils.load_device","title":"<code>load_device(device_name, device_file='device.yml', device_dir=None)</code>","text":"<p>Load a device configuration from the <code>device_dir</code> directory. The <code>device_file</code> must be located at <code>device_dir/device_name/device_file</code>. All other files in the directory, if referenced in <code>device_file</code>, will be converted to an absolute path.</p> <p>Loading a device configuration</p> <p>Currently, the only provided device configuration is for the SPT-100 thruster. <pre><code>from hallmd.utils import load_device\n\ndevice = load_device('SPT-100')\n</code></pre></p> <p>You may put custom configurations in the <code>hallmd.devices</code> directory or specify a custom directory with a custom configuration file: <pre><code>name: MyDevice\ngeometry:\n  channel_length: 1\n  inner_radius: 2\n  outer_radius: 3\nmagnetic_field:\n  file: bfield.csv\nshielded: false\n</code></pre></p> PARAMETER DESCRIPTION <code>device_name</code> <p>name of the device configuration to load</p> <p> TYPE: <code>str</code> </p> <code>device_file</code> <p>name of the device configuration file (default: 'device.yml'). Only supported file types are <code>.yml</code> and <code>.json</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'device.yml'</code> </p> <code>device_dir</code> <p>directory containing the devices. If None, the <code>hallmd.devices</code> directory is used.</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>dictionary containing the device configuration</p> Source code in <code>src/hallmd/utils.py</code> <pre><code>def load_device(device_name: str, device_file: str = 'device.yml', device_dir: str | Path = None) -&gt; dict:\n    \"\"\"Load a device configuration from the `device_dir` directory. The `device_file` must be located at\n    `device_dir/device_name/device_file`. All other files in the directory, if referenced in `device_file`, will\n    be converted to an absolute path.\n\n    !!! Example \"Loading a device configuration\"\n        Currently, the only provided device configuration is for the SPT-100 thruster.\n        ```python\n        from hallmd.utils import load_device\n\n        device = load_device('SPT-100')\n        ```\n\n    You may put custom configurations in the `hallmd.devices` directory or specify a custom directory with a custom\n    configuration file:\n    ```yaml\n    name: MyDevice\n    geometry:\n      channel_length: 1\n      inner_radius: 2\n      outer_radius: 3\n    magnetic_field:\n      file: bfield.csv\n    shielded: false\n    ```\n\n    :param device_name: name of the device configuration to load\n    :param device_file: name of the device configuration file (default: 'device.yml'). Only supported file types are\n                        `.yml` and `.json`.\n    :param device_dir: directory containing the devices. If None, the `hallmd.devices` directory is used.\n    :return: dictionary containing the device configuration\n    \"\"\"\n    device_dir = resources.files('hallmd.devices') if device_dir is None else Path(device_dir)\n    if not (device_dir / device_name).exists():\n        raise FileNotFoundError(f'Device directory \"{device_name}\" not found in the device folder.')\n    if not (device_dir / device_name / device_file).exists():\n        raise FileNotFoundError(f'Device configuration file \"{device_file}\" not found in the \"{device_name}\" '\n                                f'directory. Please rename or specify the configuration file as \"{device_file}\".')\n\n    config_file = device_dir / device_name / device_file\n    with open(config_file, 'r', encoding='utf-8') as fd:\n        if config_file.suffix == '.yml':\n            config = yaml.safe_load(fd)\n        elif config_file.suffix == '.json':\n            config = json.load(fd)\n        else:\n            raise ValueError(f'Unsupported file type \"{config_file.suffix}\". Only .yml and .json files are supported.')\n\n    # Convert all relative paths to absolute paths\n    for root, _, files in os.walk(device_dir / device_name):\n        for file in files:\n            if file != device_file:\n                # Check if the posix file path from root is in the config (i.e. \"./file.csv\")\n                root_path = Path(root) / file  # Path like \"hallmd/devices/SPT-100/path/to/file.csv\"\n                rel_path = root_path.relative_to(device_dir / device_name)  # Just the path/to/file.csv part (relative)\n                dict_path = _path_in_dict(rel_path.as_posix(), config)\n                if len(dict_path) == 0:\n                    # Check if the plain filename is in the config (i.e. file.csv); will only pick first match\n                    dict_path = _path_in_dict(file, config)\n\n                if dict_path:\n                    d = config  # pointer to the nested location in config\n                    for key in dict_path[:-2]:\n                        d = config[key]\n                    d[dict_path[-2]] = root_path.resolve().as_posix()\n\n    return config\n</code></pre>"},{"location":"reference/data/","title":"<code>hallmd.data</code>","text":"<p>The <code>hallmd.data</code> package contains a folder for each unique thruster. The experimental data for each thruster is further divided by folders for each individual paper or reference. The raw experimental data is contained within these folders in any supported format (currently only .csv). Any additional documentation for the datasets is encouraged (e.g. citations, descriptions, summaries, etc.) and can be included in the data folders.</p>"},{"location":"reference/data/#hallmd.data--thrusters","title":"Thrusters","text":""},{"location":"reference/data/#hallmd.data--spt-100","title":"SPT-100","text":"<p>Currently the only thruster with available data. Data for the SPT-100 comes from four sources:</p> <ol> <li>Diamant et al. 2014 - provides thrust and ion current density data as a function of chamber background pressure.</li> <li>Macdonald et al. 2019 - provides ion velocity profiles for varying chamber pressures.</li> <li>Sankovic et al. 1993 - provides thrust at varying operating conditions.</li> <li>Jorns and Byrne. 2021 - provides cathode coupling voltages at same conditions as Diamant et al. 2014.</li> </ol> <p>Citations: SPT-100.bib<pre><code>@incollection{diamantEffectBackgroundPressure2014,\n    title = {The {{Effect}} of {{Background Pressure}} on {{SPT-100 Hall\n             Thruster Performance}}},\n    booktitle = {50th {{AIAA}}/{{ASME}}/{{SAE}}/{{ASEE Joint Propulsion\n                 Conference}}},\n    author = {Diamant, Kevin D. and Liang, Raymond and Corey, Ron L.},\n    date = {2014-07-25},\n    series = {{{AIAA Propulsion}} and {{Energy Forum}}},\n    publisher = {{American Institute of Aeronautics and Astronautics}},\n    doi = {10.2514/6.2014-3710},\n    year = {2014},\n}\n\n@article{macdonaldBackgroundPressureEffects2019,\n    title = {Background {{Pressure Effects}} on {{Ion Velocity Distributions}}\n             in an {{SPT-100 Hall Thruster}}},\n    author = {Macdonald-Tenenbaum, Natalia and Pratt, Quinn and Nakles, Michael\n              and Pilgram, Nickolas and Holmes, Michael and Hargus, William},\n    date = {2019-01-11},\n    journaltitle = {Journal of Propulsion and Power},\n    shortjournal = {Journal of Propulsion and Power},\n    volume = {35},\n    pages = {1--10},\n    doi = {10.2514/1.B37133},\n}\n\n@inproceedings{sankovicPerformanceEvaluationRussian1993,\n    title = {Performance Evaluation of the {{Russian SPT-100}} Thruster at {{\n             NASA LeRC}}},\n    author = {Sankovic, J. and Hamley, J. and Haag, T.},\n    date = {1993-09-13/1993-09-16},\n    location = {{Seattle, WA, USA}},\n    url = {\n           https://www.semanticscholar.org/paper/Performance-evaluation-of-the-Russian-SPT-100-at-Sankovic-Hamley/81b7d985669b21aa1a8419277c52e7a879bf3b46\n           },\n    urldate = {2023-01-06},\n    eventtitle = {23rd {{International Electric Propulsion Conference}}},\n}\n\n@article{jornsCathodeCoupling2021,\n    title = {Model for the dependence of cathode voltage in a {H}all thruster on\n             facility pressure},\n    author = {Jorns, Benjamin A. and Byrne, Matthew P.},\n    date = {2021-01-12},\n    journaltitle = {Plasma Sources Science and Technology},\n    volume = {30},\n    number = {1},\n    pages = {015012},\n    publisher = {IOP Publishing},\n    doi = {10.1088/1361-6595/abd3b6},\n}\n</code></pre></p>"},{"location":"reference/data/#hallmd.data.Measurement","title":"<code>Measurement(mean, std)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A measurement object that includes a mean and standard deviation. The mean is the best estimate of the quantity being measured, and the standard deviation is the uncertainty in the measurement. Can be used to specify a scalar measurement quantity or a field quantity (e.g. a profile) in the form of a <code>numpy</code> array.</p>"},{"location":"reference/data/#hallmd.data.OperatingCondition","title":"<code>OperatingCondition(background_pressure_Torr, discharge_voltage_V, anode_mass_flow_rate_kg_s)</code>  <code>dataclass</code>","text":"<p>Operating conditions for a Hall thruster. Currently includes background pressure (Torr), discharge voltage (V), and anode mass flow rate (kg/s).</p>"},{"location":"reference/data/#hallmd.data.ThrusterData","title":"<code>ThrusterData(cathode_coupling_voltage_V=None, thrust_N=None, discharge_current_A=None, ion_current_A=None, efficiency_current=None, efficiency_mass=None, efficiency_voltage=None, efficiency_anode=None, ion_velocity_coords_m=None, ion_velocity_m_s=None, divergence_angle_rad=None, ion_current_density_radius_m=None, ion_current_density_coords_m=None, ion_current_density_A_m2=None)</code>  <code>dataclass</code>","text":"<p>Class for Hall thruster data. Contains fields for all relevant performance metrics and quantities of interest.</p>"},{"location":"reference/data/#hallmd.data.load","title":"<code>load(files)</code>","text":"<p>Load all data from the given files into a dict map of <code>OperatingCondition</code> -&gt; <code>ThrusterData</code>. Each thruster operating condition corresponds to one set of thruster measurements or quantities of interest (QoIs).</p> PARAMETER DESCRIPTION <code>files</code> <p>A list of file paths or a single file path to load data from (only .csv supported).</p> <p> TYPE: <code>list[PathLike] | PathLike</code> </p> RETURNS DESCRIPTION <code>dict[OperatingCondition, ThrusterData]</code> <p>A dict map of <code>OperatingCondition</code> -&gt; <code>ThrusterData</code> objects.</p> Source code in <code>src/hallmd/data/__init__.py</code> <pre><code>def load(files: list[PathLike] | PathLike) -&gt; dict[OperatingCondition, ThrusterData]:\n    \"\"\"Load all data from the given files into a dict map of `OperatingCondition` -&gt; `ThrusterData`.\n    Each thruster operating condition corresponds to one set of thruster measurements or quantities of interest (QoIs).\n\n    :param files: A list of file paths or a single file path to load data from (only .csv supported).\n    :return: A dict map of `OperatingCondition` -&gt; `ThrusterData` objects.\n    \"\"\"\n    data: dict[OperatingCondition, ThrusterData] = {}\n    if isinstance(files, list):\n        # Recursively load resources in this list (possibly list of lists)\n        for file in files:\n            data.update(load(file))\n    else:\n        data.update(_load_single(files))\n\n    return data\n</code></pre>"},{"location":"reference/data/spt100/","title":"<code>hallmd.data.spt100</code>","text":""},{"location":"reference/data/spt100/diamant2014/","title":"<code>hallmd.data.spt100.diamant2014</code>","text":""},{"location":"reference/data/spt100/macdonald2019/","title":"<code>hallmd.data.spt100.macdonald2019</code>","text":""},{"location":"reference/data/spt100/sankovic1993/","title":"<code>hallmd.data.spt100.sankovic1993</code>","text":""},{"location":"reference/devices/","title":"<code>hallmd.devices</code>","text":"<p>Sub-package to host information about devices (thrusters, chambers, other equipment, etc.).</p>"},{"location":"reference/models/","title":"<code>hallmd.models</code>","text":"<p>All models are specified as callable functions in <code>hallmd.models</code>. Currently supported models are based on a three-component feedforward system for a Hall thruster:</p> <ol> <li>Cathode - Accounts for interactions of the cathode plasma with the main discharge.</li> <li>Thruster - The primary simulation of the Hall thruster channel discharge and near-field.</li> <li>Plume - Models the far-field expansion of the plasma plume in the vacuum chamber.</li> </ol> <p></p> <p>Fig 1. The three-component feedforward Hall thruster model (Eckels et al 2024).</p> <p>Examples of integrated predictive engineering models (PEM) are included in the scripts folder.</p>"},{"location":"reference/models/#hallmd.models.cathode_coupling","title":"<code>cathode_coupling(inputs)</code>","text":"<p>Computes cathode coupling voltage dependence on background pressure.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>input arrays - <code>P_b</code>, <code>V_a</code>, <code>T_e</code>, <code>V_vac</code>, <code>Pstar</code>, <code>P_T</code> for background pressure (Torr), discharge voltage (V), electron temperature (eV), vacuum coupling voltage (V), and model parameters P* (Torr) and P_T (Torr).</p> <p> TYPE: <code>Dataset</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>output arrays - <code>V_cc</code> for cathode coupling voltage (V).</p> Source code in <code>src/hallmd/models/cathode.py</code> <pre><code>def cathode_coupling(inputs: Dataset) -&gt; Dataset:\n    \"\"\"Computes cathode coupling voltage dependence on background pressure.\n\n    :param inputs: input arrays - `P_b`, `V_a`, `T_e`, `V_vac`, `Pstar`, `P_T` for background pressure (Torr), discharge\n                   voltage (V), electron temperature (eV), vacuum coupling voltage (V), and model parameters P* (Torr)\n                   and P_T (Torr).\n    :returns outputs: output arrays - `V_cc` for cathode coupling voltage (V).\n    \"\"\"\n    # Load inputs\n    PB = inputs['P_b'] * TORR_2_PA          # Background Pressure (Torr)\n    Va = inputs['V_a']                      # Anode voltage (V)\n    Te = inputs['T_e']                      # Electron temperature at the cathode (eV)\n    V_vac = inputs['V_vac']                 # Vacuum coupling voltage model parameter (V)\n    Pstar = inputs['Pstar'] * TORR_2_PA     # Model parameter P* (Torr)\n    PT = inputs['P_T'] * TORR_2_PA          # Model parameter P_T (Torr)\n\n    # Compute cathode coupling voltage\n    V_cc = np.atleast_1d(V_vac + Te * np.log(1 + PB / PT) - (Te / (PT + Pstar)) * PB)\n    V_cc[V_cc &lt; 0] = 0\n    ind = np.where(V_cc &gt; Va)\n    V_cc[ind] = np.atleast_1d(Va)[ind]\n    return {'V_cc': V_cc}\n</code></pre>"},{"location":"reference/models/#hallmd.models.current_density","title":"<code>current_density(inputs)</code>","text":"<p>Compute the semi-empirical ion current density (\\(j_{ion}\\)) plume model over a 90 deg sweep, with 0 deg at thruster centerline. Also compute the plume divergence angle. Will return the ion current density at 91 points, from 0 to 90 deg in 1 deg increments. The angular locations are returned as <code>j_ion_coords</code> in radians.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>input arrays - <code>P_b</code>, <code>c0</code>, <code>c1</code>, <code>c2</code>, <code>c3</code>, <code>c4</code>, <code>c5</code>, <code>sigma_cex</code>, <code>r_p</code>, <code>I_B0</code> for background pressure (Torr), plume fit coefficients, charge-exchange cross-section (\\(m^2\\)), radial distance from thruster exit plane (m), and total initial ion beam current (A). If <code>T</code> is provided, then also compute corrected thrust using the divergence angle.</p> <p> TYPE: <code>Dataset</code> </p> RETURNS DESCRIPTION <p>output arrays - <code>j_ion</code> for ion current density (\\(A/m^2\\)) at the <code>j_ion_coords</code> locations, and <code>div_angle</code> in radians for the divergence angle of the plume. Optionally, <code>T_c</code> for corrected thrust (N) if <code>T</code> is provided in the inputs.</p> Source code in <code>src/hallmd/models/plume.py</code> <pre><code>def current_density(inputs: Dataset):\n    \"\"\"Compute the semi-empirical ion current density ($j_{ion}$) plume model over a 90 deg sweep, with 0 deg at\n    thruster centerline. Also compute the plume divergence angle. Will return the ion current density at 91 points,\n    from 0 to 90 deg in 1 deg increments. The angular locations are returned as `j_ion_coords` in radians.\n\n    :param inputs: input arrays - `P_b`, `c0`, `c1`, `c2`, `c3`, `c4`, `c5`, `sigma_cex`, `r_p`, `I_B0` for background\n                   pressure (Torr), plume fit coefficients, charge-exchange cross-section ($m^2$), radial distance\n                   from thruster exit plane (m), and total initial ion beam current (A). If `T` is provided, then\n                   also compute corrected thrust using the divergence angle.\n    :returns outputs: output arrays - `j_ion` for ion current density ($A/m^2$) at the `j_ion_coords` locations,\n                                       and `div_angle` in radians for the divergence angle of the plume. Optionally,\n                                       `T_c` for corrected thrust (N) if `T` is provided in the inputs.\n    \"\"\"\n    # Load plume inputs\n    P_B = inputs['P_b'] * TORR_2_PA     # Background pressure (Torr)\n    c0 = inputs['c0']                   # Fit coefficients (-)\n    c1 = inputs['c1']                   # (-)\n    c2 = inputs['c2']                   # (rad/Pa)\n    c3 = inputs['c3']                   # (rad)\n    c4 = inputs['c4']                   # (m^-3/Pa)\n    c5 = inputs['c5']                   # (m^-3)\n    sigma_cex = inputs['sigma_cex']     # Charge-exchange cross-section (m^2)\n    r_m = inputs['r_p']                 # Axial distance from thruster exit plane (m)\n    I_B0 = inputs['I_B0']               # Total initial ion beam current (A)\n    thrust = inputs.get('T', None)      # Thrust (N)\n\n    # 90 deg angle sweep for ion current density\n    alpha_rad = np.linspace(0, np.pi/2, 91)\n\n    # Neutral density\n    n = c4 * P_B + c5  # m^-3\n\n    # Divergence angles\n    alpha1 = np.atleast_1d(c2 * P_B + c3)  # Main beam divergence (rad)\n    alpha1[alpha1 &gt; np.pi/2] = np.pi/2\n    alpha2 = alpha1 / c1                   # Scattered beam divergence (rad)\n\n    with np.errstate(invalid='ignore', divide='ignore'):\n        A1 = (1 - c0) / ((np.pi ** (3 / 2)) / 2 * alpha1 * np.exp(-(alpha1 / 2)**2) *\n                         (2 * erfi(alpha1 / 2) + erfi((np.pi * 1j - (alpha1 ** 2)) / (2 * alpha1)) -\n                          erfi((np.pi * 1j + (alpha1 ** 2)) / (2 * alpha1))))\n        A2 = c0 / ((np.pi ** (3 / 2)) / 2 * alpha2 * np.exp(-(alpha2 / 2)**2) *\n                   (2 * erfi(alpha2 / 2) + erfi((np.pi * 1j - (alpha2 ** 2)) / (2 * alpha2)) -\n                    erfi((np.pi * 1j + (alpha2 ** 2)) / (2 * alpha2))))\n        I_B = I_B0 * np.exp(-r_m * n * sigma_cex)\n\n        base_density = np.atleast_1d(I_B / r_m ** 2)[..., np.newaxis]\n        j_beam = base_density * A1[..., np.newaxis] * np.exp(-(alpha_rad / alpha1[..., np.newaxis]) ** 2)\n        j_scat = base_density * A2[..., np.newaxis] * np.exp(-(alpha_rad / alpha2[..., np.newaxis]) ** 2)\n        j_cex = I_B0 * (1 - np.exp(-r_m * n * sigma_cex)) / (2 * np.pi * r_m ** 2)\n        j_cex = np.atleast_1d(j_cex)[..., np.newaxis]\n        j_ion = j_beam + j_scat + j_cex  # (..., 91) the current density 1d profile\n\n    # Set j~0 where alpha1 &lt; 0 (invalid cases)\n    invalid_idx = np.logical_or(alpha1 &lt;= 0, np.any(j_ion &lt;= 0, axis=-1))\n    j_ion[invalid_idx, ...] = 1e-20\n    j_cex[invalid_idx, ...] = 1e-20\n\n    if np.any(abs(j_ion.imag) &gt; 0):\n        LOGGER.warning('Predicted beam current has non-zero imaginary component.')\n    j_ion = j_ion.real\n\n    # Calculate divergence angle from https://aip.scitation.org/doi/10.1063/5.0066849\n    # Requires alpha = [0, ..., 90] deg, from thruster exit-plane to thruster centerline (need to flip)\n    # do j_beam + j_scat instead of j_ion - j_cex to avoid catastrophic loss of precision when\n    # j_beam and j_scat &lt;&lt; j_cex\n    j_non_cex = np.flip((j_beam + j_scat).real, axis=-1)\n    den_integrand = j_non_cex * np.cos(alpha_rad)\n    num_integrand = den_integrand * np.sin(alpha_rad)\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        num = simpson(num_integrand, x=alpha_rad, axis=-1)\n        den = simpson(den_integrand, x=alpha_rad, axis=-1)\n        cos_div = np.atleast_1d(num/den)\n        cos_div[cos_div == np.inf] = np.nan\n\n    div_angle = np.arccos(cos_div)  # Divergence angle (rad)\n\n    ret = {'j_ion': j_ion, 'div_angle': div_angle}\n\n    if thrust is not None:\n        ret['T_c'] = thrust * cos_div\n\n    # Interpolate to requested angles\n    # if j_ion_coords is not None:\n    #     # Extend to range (-90, 90) deg\n    #     alpha_grid = np.concatenate((-np.flip(alpha_rad)[:-1], alpha_rad))               # (2M-1,)\n    #     jion_grid = np.concatenate((np.flip(j_ion, axis=-1)[..., :-1], j_ion), axis=-1)  # (..., 2M-1)\n    #\n    #     f = interp1d(alpha_grid, jion_grid, axis=-1)\n    #     j_ion = f(j_ion_coords)  # (..., num_pts)\n\n    # Broadcast coords to same loop shape as j_ion (all use the same coords -- store in object array)\n    j_ion_coords = np.empty(j_ion.shape[:-1], dtype=object)\n    for index in np.ndindex(j_ion.shape[:-1]):\n        j_ion_coords[index] = alpha_rad\n\n    ret['j_ion_coords'] = j_ion_coords\n\n    return ret\n</code></pre>"},{"location":"reference/models/#hallmd.models.hallthruster_jl","title":"<code>hallthruster_jl(thruster_inputs=None, thruster='SPT-100', config=None, simulation=None, postprocess=None, model_fidelity=(2, 2), output_path=None, version=HALLTHRUSTER_VERSION_DEFAULT, pem_to_julia='default', fidelity_function='default', julia_script=None, run_kwargs='default')</code>","text":"<p>Run a single <code>HallThruster.jl</code> simulation for a given set of inputs. This function will write a temporary input file to disk, call <code>HallThruster.run_simulation()</code> in Julia, and read the output file back into Python. Will return time-averaged performance metrics and ion velocity for use with the PEM.</p> <p>Note that the specific inputs and outputs described here can be configured using the <code>pem_to_julia</code> dict.</p> <p>Required configuration</p> <p>You must specify a thruster, a domain, a mass flow rate, and a discharge voltage to run the simulation. The thruster must be defined in the <code>hallmd.devices</code> directory or as a dictionary with the required fields. The mass flow rate and discharge voltage are specified in <code>thruster_inputs</code> as <code>mdot_a</code> (kg/s) and <code>V_a</code> (V), respectively. The domain is specified as a list <code>[left_bound, right_bound]</code> in the <code>config</code> dictionary. See the HallThruster.jl docs for more details.</p> PARAMETER DESCRIPTION <code>thruster_inputs</code> <p>named key-value pairs of thruster inputs: <code>P_b</code>, <code>V_a</code>, <code>mdot_a</code>, <code>T_e</code>, <code>u_n</code>, <code>l_t</code>, <code>a_1</code>, <code>a_2</code>, <code>delta_z</code>, <code>z0</code>, <code>p0</code>, and <code>V_cc</code> for background pressure (Torr), anode voltage, anode mass flow rate (kg/s), electron temperature (eV), neutral velocity (m/s), transition length (m), anomalous transport coefficients, and cathode coupling voltage. Will override the corresponding values in <code>config</code> if provided.</p> <p> TYPE: <code>Dataset</code> DEFAULT: <code>None</code> </p> <code>thruster</code> <p>the name of the thruster to simulate (must be importable from <code>hallmd.devices</code>, see <code>load_device</code>), or a dictionary that provides geometry and magnetic field information of the thruster to simulate; see the Hallthruster.jl docs. Will override <code>thruster</code> in <code>config</code> if provided. If None, will defer to <code>config</code>. Defaults to the SPT-100.</p> <p> TYPE: <code>Literal['SPT-100'] | str | dict</code> DEFAULT: <code>'SPT-100'</code> </p> <code>config</code> <p>dictionary of configs for <code>HallThruster.jl</code>, see the Hallthruster.jl docs for options and formatting.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>simulation</code> <p>dictionary of simulation parameters for <code>HallThruster.jl</code></p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>postprocess</code> <p>dictionary of post-processing parameters for <code>Hallthruster.jl</code></p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>model_fidelity</code> <p>tuple of integers that determine the number of cells and the number of charge states to use via <code>ncells = model_fidelity[0] * 50 + 100</code> and <code>ncharge = model_fidelity[1] + 1</code>. Will override <code>ncells</code> and <code>ncharge</code> in <code>simulation</code> and <code>config</code> if provided.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>(2, 2)</code> </p> <code>output_path</code> <p>base path to save output files, will write to current directory if not specified</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>version of HallThruster.jl to use; will search for a global <code>hallthruster_{version}</code> environment in the <code>~/.julia/environments/</code> directory. Can also specify a specific git ref (i.e. branch, commit hash, etc.) to use from GitHub. If the <code>hallthruster_{version}</code> environment does not exist, an error will be raised -- you should create this environment first before using it.</p> <p> TYPE: <code>str</code> DEFAULT: <code>HALLTHRUSTER_VERSION_DEFAULT</code> </p> <code>pem_to_julia</code> <p>a <code>dict</code> mapping of PEM shorthand variable names to a list of keys that maps into the <code>HallThruster.jl</code> input/output data structure. Defaults to the provided PEM_TO_JULIA dict defined in <code>hallmd.models.thruster</code>. For example, <code>{'P_b': ['config', 'background_pressure']}</code> will set <code>config['background_pressure'] = P_b</code>. If specified, will override and extend the default mapping.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>'default'</code> </p> <code>fidelity_function</code> <p>a callable that takes a tuple of integers and returns a dictionary of simulation parameters. Defaults to <code>_default_model_fidelity</code> which sets <code>ncells</code> and <code>ncharge</code> based on the input tuple. The returned simulation parameters must be convertable to Julia via the <code>pem_to_julia</code> mapping. The callable should also take in the current json config dict.</p> <p> TYPE: <code>Callable[[tuple[int, ...]], dict]</code> DEFAULT: <code>'default'</code> </p> <code>julia_script</code> <p>path to a custom Julia script to run. The script should accept the input json file path as a command line argument. Defaults to just calling <code>HallThruster.run_simulation(input_file)</code>.</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> <code>run_kwargs</code> <p>additional keyword arguments to pass to <code>subprocess.run</code> when calling the Julia script. Defaults to <code>check=True</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>'default'</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p><code>dict</code> of <code>Hallthruster.jl</code> outputs: <code>I_B0</code>, <code>I_d</code>, <code>T</code>, <code>eta_c</code>, <code>eta_m</code>, <code>eta_v</code>, and <code>u_ion</code> for ion beam current (A), discharge current (A), thrust (N), current efficiency, mass efficiency, voltage efficiency, and singly-charged ion velocity profile (m/s), all time-averaged.</p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def hallthruster_jl(\n    thruster_inputs: Dataset = None,\n    thruster: Literal[\"SPT-100\"] | str | dict = \"SPT-100\",\n    config: dict = None,\n    simulation: dict = None,\n    postprocess: dict = None,\n    model_fidelity: tuple = (2, 2),\n    output_path: str | Path = None,\n    version: str = HALLTHRUSTER_VERSION_DEFAULT,\n    pem_to_julia: dict = \"default\",\n    fidelity_function: Callable[[tuple[int, ...]], dict] = \"default\",\n    julia_script: str | Path = None,\n    run_kwargs: dict = \"default\",\n) -&gt; Dataset:\n    \"\"\"Run a single `HallThruster.jl` simulation for a given set of inputs. This function will write a temporary\n    input file to disk, call `HallThruster.run_simulation()` in Julia, and read the output file back into Python. Will\n    return time-averaged performance metrics and ion velocity for use with the PEM.\n\n    Note that the specific inputs and outputs described here can be configured using the `pem_to_julia` dict.\n\n    !!! Warning \"Required configuration\"\n        You must specify a thruster, a domain, a mass flow rate, and a discharge voltage to run the simulation. The\n        thruster must be defined in the `hallmd.devices` directory or as a dictionary with the required fields.\n        The mass flow rate and discharge voltage are specified in `thruster_inputs` as `mdot_a` (kg/s) and\n        `V_a` (V), respectively. The domain is specified as a list `[left_bound, right_bound]` in the\n        `config` dictionary. See the\n        [HallThruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/reference/config/) for more details.\n\n    :param thruster_inputs: named key-value pairs of thruster inputs: `P_b`, `V_a`, `mdot_a`, `T_e`, `u_n`, `l_t`,\n                            `a_1`, `a_2`, `delta_z`, `z0`, `p0`, and `V_cc` for background pressure (Torr), anode\n                            voltage, anode mass flow rate (kg/s), electron temperature (eV), neutral velocity (m/s),\n                            transition length (m), anomalous transport coefficients, and cathode coupling voltage. Will\n                            override the corresponding values in `config` if provided.\n    :param thruster: the name of the thruster to simulate (must be importable from `hallmd.devices`, see\n                     [`load_device`][hallmd.utils.load_device]), or a dictionary that provides geometry and\n                     magnetic field information of the thruster to simulate; see the\n                     [Hallthruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/tutorials/simulation//run/).\n                     Will override `thruster` in `config` if provided. If None, will defer to `config`.\n                     Defaults to the SPT-100.\n    :param config: dictionary of configs for `HallThruster.jl`, see the\n                   [Hallthruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/reference/config/) for\n                   options and formatting.\n    :param simulation: dictionary of simulation parameters for `HallThruster.jl`\n    :param postprocess: dictionary of post-processing parameters for `Hallthruster.jl`\n    :param model_fidelity: tuple of integers that determine the number of cells and the number of charge states to use\n                           via `ncells = model_fidelity[0] * 50 + 100` and `ncharge = model_fidelity[1] + 1`.\n                           Will override `ncells` and `ncharge` in `simulation` and `config` if provided.\n    :param output_path: base path to save output files, will write to current directory if not specified\n    :param version: version of HallThruster.jl to use; will\n                    search for a global `hallthruster_{version}` environment in the `~/.julia/environments/` directory.\n                    Can also specify a specific git ref (i.e. branch, commit hash, etc.) to use from GitHub. If the\n                    `hallthruster_{version}` environment does not exist, an error will be raised -- you should create\n                    this environment first before using it.\n    :param pem_to_julia: a `dict` mapping of PEM shorthand variable names to a list of keys that maps into the\n                         `HallThruster.jl` input/output data structure. Defaults to the provided PEM_TO_JULIA dict\n                         defined in [`hallmd.models.thruster`][hallmd.models.thruster]. For example,\n                         `{'P_b': ['config', 'background_pressure']}` will set `config['background_pressure'] = P_b`.\n                         If specified, will override and extend the default mapping.\n    :param fidelity_function: a callable that takes a tuple of integers and returns a dictionary of simulation\n                              parameters. Defaults to `_default_model_fidelity` which sets `ncells` and `ncharge` based\n                              on the input tuple. The returned simulation parameters must be convertable to Julia via\n                              the `pem_to_julia` mapping. The callable should also take in the current json config dict.\n    :param julia_script: path to a custom Julia script to run. The script should accept the input json file path as\n                         a command line argument. Defaults to just calling `HallThruster.run_simulation(input_file)`.\n    :param run_kwargs: additional keyword arguments to pass to `subprocess.run` when calling the Julia script.\n                       Defaults to `check=True`.\n    :returns: `dict` of `Hallthruster.jl` outputs: `I_B0`, `I_d`, `T`, `eta_c`, `eta_m`, `eta_v`, and `u_ion` for ion\n              beam current (A), discharge current (A), thrust (N), current efficiency, mass efficiency, voltage\n              efficiency, and singly-charged ion velocity profile (m/s), all time-averaged.\n    \"\"\"\n    if pem_to_julia is None or pem_to_julia == \"default\":\n        pem_to_julia = copy.deepcopy(PEM_TO_JULIA)\n    else:\n        tmp = copy.deepcopy(PEM_TO_JULIA)\n        tmp.update(pem_to_julia)\n        pem_to_julia = tmp\n\n    thruster_inputs = thruster_inputs or {}\n\n    # Format PEM inputs for HallThruster.jl\n    json_data = _format_hallthruster_jl_input(\n        thruster_inputs,\n        thruster=thruster,\n        config=config,\n        simulation=simulation,\n        postprocess=postprocess,\n        model_fidelity=model_fidelity,\n        output_path=output_path,\n        pem_to_julia=pem_to_julia,\n        fidelity_function=fidelity_function,\n    )\n    # Get julia environment\n    jl_environment = get_jl_env(version) if version is not None else None\n\n    if run_kwargs is None:\n        run_kwargs = {}\n    elif run_kwargs == \"default\":\n        run_kwargs = {\"check\": True}\n\n    # Run Julia\n    t1 = time.time()\n    sim_results = run_hallthruster_jl(json_data, jl_env=jl_environment, jl_script=julia_script, **run_kwargs)\n    t2 = time.time()\n\n    # Format QOIs for PEM\n    thruster_outputs = _convert_to_pem(sim_results, pem_to_julia)\n\n    # Raise an exception if thrust or beam current are negative (non-physical cases)\n    thrust = thruster_outputs.get(\"T\", 0)\n    beam_current = thruster_outputs.get(\"I_B0\", 0)\n    if thrust &lt; 0 or beam_current &lt; 0:\n        raise ValueError(f\"Exception due to non-physical case: thrust={thrust} N, beam current={beam_current} A\")\n\n    thruster_outputs[\"model_cost\"] = t2 - t1  # seconds\n\n    if output_path is not None:\n        output_file = Path(json_data[\"postprocess\"].get(\"output_file\"))\n        thruster_outputs[\"output_path\"] = output_file.relative_to(Path(output_path).resolve()).as_posix()\n\n    return thruster_outputs\n</code></pre>"},{"location":"reference/models/cathode/","title":"cathode","text":""},{"location":"reference/models/cathode/#hallmd.models.cathode","title":"<code>hallmd.models.cathode</code>","text":"<p>Module for cathode models.</p> <p>Includes:</p> <ul> <li><code>cathode_coupling()</code> - cathode coupling model with pressure dependence (Jorns 2021)</li> </ul>"},{"location":"reference/models/cathode/#hallmd.models.cathode.cathode_coupling","title":"<code>cathode_coupling(inputs)</code>","text":"<p>Computes cathode coupling voltage dependence on background pressure.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>input arrays - <code>P_b</code>, <code>V_a</code>, <code>T_e</code>, <code>V_vac</code>, <code>Pstar</code>, <code>P_T</code> for background pressure (Torr), discharge voltage (V), electron temperature (eV), vacuum coupling voltage (V), and model parameters P* (Torr) and P_T (Torr).</p> <p> TYPE: <code>Dataset</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>output arrays - <code>V_cc</code> for cathode coupling voltage (V).</p> Source code in <code>src/hallmd/models/cathode.py</code> <pre><code>def cathode_coupling(inputs: Dataset) -&gt; Dataset:\n    \"\"\"Computes cathode coupling voltage dependence on background pressure.\n\n    :param inputs: input arrays - `P_b`, `V_a`, `T_e`, `V_vac`, `Pstar`, `P_T` for background pressure (Torr), discharge\n                   voltage (V), electron temperature (eV), vacuum coupling voltage (V), and model parameters P* (Torr)\n                   and P_T (Torr).\n    :returns outputs: output arrays - `V_cc` for cathode coupling voltage (V).\n    \"\"\"\n    # Load inputs\n    PB = inputs['P_b'] * TORR_2_PA          # Background Pressure (Torr)\n    Va = inputs['V_a']                      # Anode voltage (V)\n    Te = inputs['T_e']                      # Electron temperature at the cathode (eV)\n    V_vac = inputs['V_vac']                 # Vacuum coupling voltage model parameter (V)\n    Pstar = inputs['Pstar'] * TORR_2_PA     # Model parameter P* (Torr)\n    PT = inputs['P_T'] * TORR_2_PA          # Model parameter P_T (Torr)\n\n    # Compute cathode coupling voltage\n    V_cc = np.atleast_1d(V_vac + Te * np.log(1 + PB / PT) - (Te / (PT + Pstar)) * PB)\n    V_cc[V_cc &lt; 0] = 0\n    ind = np.where(V_cc &gt; Va)\n    V_cc[ind] = np.atleast_1d(Va)[ind]\n    return {'V_cc': V_cc}\n</code></pre>"},{"location":"reference/models/plume/","title":"plume","text":""},{"location":"reference/models/plume/#hallmd.models.plume","title":"<code>hallmd.models.plume</code>","text":"<p>Module for Hall thruster plume models.</p> <p>Includes:</p> <ul> <li><code>current_density()</code> - Semi-empirical ion current density model with \\(1/r^2\\) Gaussian beam.</li> </ul>"},{"location":"reference/models/plume/#hallmd.models.plume.current_density","title":"<code>current_density(inputs)</code>","text":"<p>Compute the semi-empirical ion current density (\\(j_{ion}\\)) plume model over a 90 deg sweep, with 0 deg at thruster centerline. Also compute the plume divergence angle. Will return the ion current density at 91 points, from 0 to 90 deg in 1 deg increments. The angular locations are returned as <code>j_ion_coords</code> in radians.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>input arrays - <code>P_b</code>, <code>c0</code>, <code>c1</code>, <code>c2</code>, <code>c3</code>, <code>c4</code>, <code>c5</code>, <code>sigma_cex</code>, <code>r_p</code>, <code>I_B0</code> for background pressure (Torr), plume fit coefficients, charge-exchange cross-section (\\(m^2\\)), radial distance from thruster exit plane (m), and total initial ion beam current (A). If <code>T</code> is provided, then also compute corrected thrust using the divergence angle.</p> <p> TYPE: <code>Dataset</code> </p> RETURNS DESCRIPTION <p>output arrays - <code>j_ion</code> for ion current density (\\(A/m^2\\)) at the <code>j_ion_coords</code> locations, and <code>div_angle</code> in radians for the divergence angle of the plume. Optionally, <code>T_c</code> for corrected thrust (N) if <code>T</code> is provided in the inputs.</p> Source code in <code>src/hallmd/models/plume.py</code> <pre><code>def current_density(inputs: Dataset):\n    \"\"\"Compute the semi-empirical ion current density ($j_{ion}$) plume model over a 90 deg sweep, with 0 deg at\n    thruster centerline. Also compute the plume divergence angle. Will return the ion current density at 91 points,\n    from 0 to 90 deg in 1 deg increments. The angular locations are returned as `j_ion_coords` in radians.\n\n    :param inputs: input arrays - `P_b`, `c0`, `c1`, `c2`, `c3`, `c4`, `c5`, `sigma_cex`, `r_p`, `I_B0` for background\n                   pressure (Torr), plume fit coefficients, charge-exchange cross-section ($m^2$), radial distance\n                   from thruster exit plane (m), and total initial ion beam current (A). If `T` is provided, then\n                   also compute corrected thrust using the divergence angle.\n    :returns outputs: output arrays - `j_ion` for ion current density ($A/m^2$) at the `j_ion_coords` locations,\n                                       and `div_angle` in radians for the divergence angle of the plume. Optionally,\n                                       `T_c` for corrected thrust (N) if `T` is provided in the inputs.\n    \"\"\"\n    # Load plume inputs\n    P_B = inputs['P_b'] * TORR_2_PA     # Background pressure (Torr)\n    c0 = inputs['c0']                   # Fit coefficients (-)\n    c1 = inputs['c1']                   # (-)\n    c2 = inputs['c2']                   # (rad/Pa)\n    c3 = inputs['c3']                   # (rad)\n    c4 = inputs['c4']                   # (m^-3/Pa)\n    c5 = inputs['c5']                   # (m^-3)\n    sigma_cex = inputs['sigma_cex']     # Charge-exchange cross-section (m^2)\n    r_m = inputs['r_p']                 # Axial distance from thruster exit plane (m)\n    I_B0 = inputs['I_B0']               # Total initial ion beam current (A)\n    thrust = inputs.get('T', None)      # Thrust (N)\n\n    # 90 deg angle sweep for ion current density\n    alpha_rad = np.linspace(0, np.pi/2, 91)\n\n    # Neutral density\n    n = c4 * P_B + c5  # m^-3\n\n    # Divergence angles\n    alpha1 = np.atleast_1d(c2 * P_B + c3)  # Main beam divergence (rad)\n    alpha1[alpha1 &gt; np.pi/2] = np.pi/2\n    alpha2 = alpha1 / c1                   # Scattered beam divergence (rad)\n\n    with np.errstate(invalid='ignore', divide='ignore'):\n        A1 = (1 - c0) / ((np.pi ** (3 / 2)) / 2 * alpha1 * np.exp(-(alpha1 / 2)**2) *\n                         (2 * erfi(alpha1 / 2) + erfi((np.pi * 1j - (alpha1 ** 2)) / (2 * alpha1)) -\n                          erfi((np.pi * 1j + (alpha1 ** 2)) / (2 * alpha1))))\n        A2 = c0 / ((np.pi ** (3 / 2)) / 2 * alpha2 * np.exp(-(alpha2 / 2)**2) *\n                   (2 * erfi(alpha2 / 2) + erfi((np.pi * 1j - (alpha2 ** 2)) / (2 * alpha2)) -\n                    erfi((np.pi * 1j + (alpha2 ** 2)) / (2 * alpha2))))\n        I_B = I_B0 * np.exp(-r_m * n * sigma_cex)\n\n        base_density = np.atleast_1d(I_B / r_m ** 2)[..., np.newaxis]\n        j_beam = base_density * A1[..., np.newaxis] * np.exp(-(alpha_rad / alpha1[..., np.newaxis]) ** 2)\n        j_scat = base_density * A2[..., np.newaxis] * np.exp(-(alpha_rad / alpha2[..., np.newaxis]) ** 2)\n        j_cex = I_B0 * (1 - np.exp(-r_m * n * sigma_cex)) / (2 * np.pi * r_m ** 2)\n        j_cex = np.atleast_1d(j_cex)[..., np.newaxis]\n        j_ion = j_beam + j_scat + j_cex  # (..., 91) the current density 1d profile\n\n    # Set j~0 where alpha1 &lt; 0 (invalid cases)\n    invalid_idx = np.logical_or(alpha1 &lt;= 0, np.any(j_ion &lt;= 0, axis=-1))\n    j_ion[invalid_idx, ...] = 1e-20\n    j_cex[invalid_idx, ...] = 1e-20\n\n    if np.any(abs(j_ion.imag) &gt; 0):\n        LOGGER.warning('Predicted beam current has non-zero imaginary component.')\n    j_ion = j_ion.real\n\n    # Calculate divergence angle from https://aip.scitation.org/doi/10.1063/5.0066849\n    # Requires alpha = [0, ..., 90] deg, from thruster exit-plane to thruster centerline (need to flip)\n    # do j_beam + j_scat instead of j_ion - j_cex to avoid catastrophic loss of precision when\n    # j_beam and j_scat &lt;&lt; j_cex\n    j_non_cex = np.flip((j_beam + j_scat).real, axis=-1)\n    den_integrand = j_non_cex * np.cos(alpha_rad)\n    num_integrand = den_integrand * np.sin(alpha_rad)\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        num = simpson(num_integrand, x=alpha_rad, axis=-1)\n        den = simpson(den_integrand, x=alpha_rad, axis=-1)\n        cos_div = np.atleast_1d(num/den)\n        cos_div[cos_div == np.inf] = np.nan\n\n    div_angle = np.arccos(cos_div)  # Divergence angle (rad)\n\n    ret = {'j_ion': j_ion, 'div_angle': div_angle}\n\n    if thrust is not None:\n        ret['T_c'] = thrust * cos_div\n\n    # Interpolate to requested angles\n    # if j_ion_coords is not None:\n    #     # Extend to range (-90, 90) deg\n    #     alpha_grid = np.concatenate((-np.flip(alpha_rad)[:-1], alpha_rad))               # (2M-1,)\n    #     jion_grid = np.concatenate((np.flip(j_ion, axis=-1)[..., :-1], j_ion), axis=-1)  # (..., 2M-1)\n    #\n    #     f = interp1d(alpha_grid, jion_grid, axis=-1)\n    #     j_ion = f(j_ion_coords)  # (..., num_pts)\n\n    # Broadcast coords to same loop shape as j_ion (all use the same coords -- store in object array)\n    j_ion_coords = np.empty(j_ion.shape[:-1], dtype=object)\n    for index in np.ndindex(j_ion.shape[:-1]):\n        j_ion_coords[index] = alpha_rad\n\n    ret['j_ion_coords'] = j_ion_coords\n\n    return ret\n</code></pre>"},{"location":"reference/models/thruster/","title":"thruster","text":""},{"location":"reference/models/thruster/#hallmd.models.thruster","title":"<code>hallmd.models.thruster</code>","text":"<p>Module for Hall thruster models.</p> <p>Note</p> <p>Only current implementation is for the 1d fluid Hallthruster.jl code. Other thruster codes can be implemented similarly here.</p> <p>Includes:</p> <ul> <li><code>run_hallthruster_jl</code> - General wrapper to run HallThruster.jl for a single set of inputs</li> <li><code>hallthruster_jl()</code> - PEM wrapper to run HallThruster.jl for a set of PEM inputs</li> <li><code>get_jl_env</code> - Get the path of the julia environment created for HallThruster.jl for a specific git ref</li> <li><code>PEM_TO_JULIA</code> - Mapping of PEM variable names to a path in the HallThruster.jl input/output structure (defaults)</li> </ul>"},{"location":"reference/models/thruster/#hallmd.models.thruster.get_jl_env","title":"<code>get_jl_env(git_ref)</code>","text":"<p>Get the path of the julia environment created for HallThruster.jl for a specific git ref.</p> PARAMETER DESCRIPTION <code>git_ref</code> <p>The git ref (i.e. commit hash, version tag, branch, etc.) of HallThruster.jl to use.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def get_jl_env(git_ref: str) -&gt; Path:\n    \"\"\"Get the path of the julia environment created for HallThruster.jl for a specific git ref.\n\n    :param git_ref: The git ref (i.e. commit hash, version tag, branch, etc.) of HallThruster.jl to use.\n    \"\"\"\n    global_env_dir = Path(\"~/.julia/environments/\").expanduser()\n    env_path = global_env_dir / f\"hallthruster_{git_ref}\"\n    return env_path\n</code></pre>"},{"location":"reference/models/thruster/#hallmd.models.thruster.hallthruster_jl","title":"<code>hallthruster_jl(thruster_inputs=None, thruster='SPT-100', config=None, simulation=None, postprocess=None, model_fidelity=(2, 2), output_path=None, version=HALLTHRUSTER_VERSION_DEFAULT, pem_to_julia='default', fidelity_function='default', julia_script=None, run_kwargs='default')</code>","text":"<p>Run a single <code>HallThruster.jl</code> simulation for a given set of inputs. This function will write a temporary input file to disk, call <code>HallThruster.run_simulation()</code> in Julia, and read the output file back into Python. Will return time-averaged performance metrics and ion velocity for use with the PEM.</p> <p>Note that the specific inputs and outputs described here can be configured using the <code>pem_to_julia</code> dict.</p> <p>Required configuration</p> <p>You must specify a thruster, a domain, a mass flow rate, and a discharge voltage to run the simulation. The thruster must be defined in the <code>hallmd.devices</code> directory or as a dictionary with the required fields. The mass flow rate and discharge voltage are specified in <code>thruster_inputs</code> as <code>mdot_a</code> (kg/s) and <code>V_a</code> (V), respectively. The domain is specified as a list <code>[left_bound, right_bound]</code> in the <code>config</code> dictionary. See the HallThruster.jl docs for more details.</p> PARAMETER DESCRIPTION <code>thruster_inputs</code> <p>named key-value pairs of thruster inputs: <code>P_b</code>, <code>V_a</code>, <code>mdot_a</code>, <code>T_e</code>, <code>u_n</code>, <code>l_t</code>, <code>a_1</code>, <code>a_2</code>, <code>delta_z</code>, <code>z0</code>, <code>p0</code>, and <code>V_cc</code> for background pressure (Torr), anode voltage, anode mass flow rate (kg/s), electron temperature (eV), neutral velocity (m/s), transition length (m), anomalous transport coefficients, and cathode coupling voltage. Will override the corresponding values in <code>config</code> if provided.</p> <p> TYPE: <code>Dataset</code> DEFAULT: <code>None</code> </p> <code>thruster</code> <p>the name of the thruster to simulate (must be importable from <code>hallmd.devices</code>, see <code>load_device</code>), or a dictionary that provides geometry and magnetic field information of the thruster to simulate; see the Hallthruster.jl docs. Will override <code>thruster</code> in <code>config</code> if provided. If None, will defer to <code>config</code>. Defaults to the SPT-100.</p> <p> TYPE: <code>Literal['SPT-100'] | str | dict</code> DEFAULT: <code>'SPT-100'</code> </p> <code>config</code> <p>dictionary of configs for <code>HallThruster.jl</code>, see the Hallthruster.jl docs for options and formatting.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>simulation</code> <p>dictionary of simulation parameters for <code>HallThruster.jl</code></p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>postprocess</code> <p>dictionary of post-processing parameters for <code>Hallthruster.jl</code></p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>model_fidelity</code> <p>tuple of integers that determine the number of cells and the number of charge states to use via <code>ncells = model_fidelity[0] * 50 + 100</code> and <code>ncharge = model_fidelity[1] + 1</code>. Will override <code>ncells</code> and <code>ncharge</code> in <code>simulation</code> and <code>config</code> if provided.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>(2, 2)</code> </p> <code>output_path</code> <p>base path to save output files, will write to current directory if not specified</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>version of HallThruster.jl to use; will search for a global <code>hallthruster_{version}</code> environment in the <code>~/.julia/environments/</code> directory. Can also specify a specific git ref (i.e. branch, commit hash, etc.) to use from GitHub. If the <code>hallthruster_{version}</code> environment does not exist, an error will be raised -- you should create this environment first before using it.</p> <p> TYPE: <code>str</code> DEFAULT: <code>HALLTHRUSTER_VERSION_DEFAULT</code> </p> <code>pem_to_julia</code> <p>a <code>dict</code> mapping of PEM shorthand variable names to a list of keys that maps into the <code>HallThruster.jl</code> input/output data structure. Defaults to the provided PEM_TO_JULIA dict defined in <code>hallmd.models.thruster</code>. For example, <code>{'P_b': ['config', 'background_pressure']}</code> will set <code>config['background_pressure'] = P_b</code>. If specified, will override and extend the default mapping.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>'default'</code> </p> <code>fidelity_function</code> <p>a callable that takes a tuple of integers and returns a dictionary of simulation parameters. Defaults to <code>_default_model_fidelity</code> which sets <code>ncells</code> and <code>ncharge</code> based on the input tuple. The returned simulation parameters must be convertable to Julia via the <code>pem_to_julia</code> mapping. The callable should also take in the current json config dict.</p> <p> TYPE: <code>Callable[[tuple[int, ...]], dict]</code> DEFAULT: <code>'default'</code> </p> <code>julia_script</code> <p>path to a custom Julia script to run. The script should accept the input json file path as a command line argument. Defaults to just calling <code>HallThruster.run_simulation(input_file)</code>.</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> <code>run_kwargs</code> <p>additional keyword arguments to pass to <code>subprocess.run</code> when calling the Julia script. Defaults to <code>check=True</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>'default'</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p><code>dict</code> of <code>Hallthruster.jl</code> outputs: <code>I_B0</code>, <code>I_d</code>, <code>T</code>, <code>eta_c</code>, <code>eta_m</code>, <code>eta_v</code>, and <code>u_ion</code> for ion beam current (A), discharge current (A), thrust (N), current efficiency, mass efficiency, voltage efficiency, and singly-charged ion velocity profile (m/s), all time-averaged.</p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def hallthruster_jl(\n    thruster_inputs: Dataset = None,\n    thruster: Literal[\"SPT-100\"] | str | dict = \"SPT-100\",\n    config: dict = None,\n    simulation: dict = None,\n    postprocess: dict = None,\n    model_fidelity: tuple = (2, 2),\n    output_path: str | Path = None,\n    version: str = HALLTHRUSTER_VERSION_DEFAULT,\n    pem_to_julia: dict = \"default\",\n    fidelity_function: Callable[[tuple[int, ...]], dict] = \"default\",\n    julia_script: str | Path = None,\n    run_kwargs: dict = \"default\",\n) -&gt; Dataset:\n    \"\"\"Run a single `HallThruster.jl` simulation for a given set of inputs. This function will write a temporary\n    input file to disk, call `HallThruster.run_simulation()` in Julia, and read the output file back into Python. Will\n    return time-averaged performance metrics and ion velocity for use with the PEM.\n\n    Note that the specific inputs and outputs described here can be configured using the `pem_to_julia` dict.\n\n    !!! Warning \"Required configuration\"\n        You must specify a thruster, a domain, a mass flow rate, and a discharge voltage to run the simulation. The\n        thruster must be defined in the `hallmd.devices` directory or as a dictionary with the required fields.\n        The mass flow rate and discharge voltage are specified in `thruster_inputs` as `mdot_a` (kg/s) and\n        `V_a` (V), respectively. The domain is specified as a list `[left_bound, right_bound]` in the\n        `config` dictionary. See the\n        [HallThruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/reference/config/) for more details.\n\n    :param thruster_inputs: named key-value pairs of thruster inputs: `P_b`, `V_a`, `mdot_a`, `T_e`, `u_n`, `l_t`,\n                            `a_1`, `a_2`, `delta_z`, `z0`, `p0`, and `V_cc` for background pressure (Torr), anode\n                            voltage, anode mass flow rate (kg/s), electron temperature (eV), neutral velocity (m/s),\n                            transition length (m), anomalous transport coefficients, and cathode coupling voltage. Will\n                            override the corresponding values in `config` if provided.\n    :param thruster: the name of the thruster to simulate (must be importable from `hallmd.devices`, see\n                     [`load_device`][hallmd.utils.load_device]), or a dictionary that provides geometry and\n                     magnetic field information of the thruster to simulate; see the\n                     [Hallthruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/tutorials/simulation//run/).\n                     Will override `thruster` in `config` if provided. If None, will defer to `config`.\n                     Defaults to the SPT-100.\n    :param config: dictionary of configs for `HallThruster.jl`, see the\n                   [Hallthruster.jl docs](https://um-pepl.github.io/HallThruster.jl/dev/reference/config/) for\n                   options and formatting.\n    :param simulation: dictionary of simulation parameters for `HallThruster.jl`\n    :param postprocess: dictionary of post-processing parameters for `Hallthruster.jl`\n    :param model_fidelity: tuple of integers that determine the number of cells and the number of charge states to use\n                           via `ncells = model_fidelity[0] * 50 + 100` and `ncharge = model_fidelity[1] + 1`.\n                           Will override `ncells` and `ncharge` in `simulation` and `config` if provided.\n    :param output_path: base path to save output files, will write to current directory if not specified\n    :param version: version of HallThruster.jl to use; will\n                    search for a global `hallthruster_{version}` environment in the `~/.julia/environments/` directory.\n                    Can also specify a specific git ref (i.e. branch, commit hash, etc.) to use from GitHub. If the\n                    `hallthruster_{version}` environment does not exist, an error will be raised -- you should create\n                    this environment first before using it.\n    :param pem_to_julia: a `dict` mapping of PEM shorthand variable names to a list of keys that maps into the\n                         `HallThruster.jl` input/output data structure. Defaults to the provided PEM_TO_JULIA dict\n                         defined in [`hallmd.models.thruster`][hallmd.models.thruster]. For example,\n                         `{'P_b': ['config', 'background_pressure']}` will set `config['background_pressure'] = P_b`.\n                         If specified, will override and extend the default mapping.\n    :param fidelity_function: a callable that takes a tuple of integers and returns a dictionary of simulation\n                              parameters. Defaults to `_default_model_fidelity` which sets `ncells` and `ncharge` based\n                              on the input tuple. The returned simulation parameters must be convertable to Julia via\n                              the `pem_to_julia` mapping. The callable should also take in the current json config dict.\n    :param julia_script: path to a custom Julia script to run. The script should accept the input json file path as\n                         a command line argument. Defaults to just calling `HallThruster.run_simulation(input_file)`.\n    :param run_kwargs: additional keyword arguments to pass to `subprocess.run` when calling the Julia script.\n                       Defaults to `check=True`.\n    :returns: `dict` of `Hallthruster.jl` outputs: `I_B0`, `I_d`, `T`, `eta_c`, `eta_m`, `eta_v`, and `u_ion` for ion\n              beam current (A), discharge current (A), thrust (N), current efficiency, mass efficiency, voltage\n              efficiency, and singly-charged ion velocity profile (m/s), all time-averaged.\n    \"\"\"\n    if pem_to_julia is None or pem_to_julia == \"default\":\n        pem_to_julia = copy.deepcopy(PEM_TO_JULIA)\n    else:\n        tmp = copy.deepcopy(PEM_TO_JULIA)\n        tmp.update(pem_to_julia)\n        pem_to_julia = tmp\n\n    thruster_inputs = thruster_inputs or {}\n\n    # Format PEM inputs for HallThruster.jl\n    json_data = _format_hallthruster_jl_input(\n        thruster_inputs,\n        thruster=thruster,\n        config=config,\n        simulation=simulation,\n        postprocess=postprocess,\n        model_fidelity=model_fidelity,\n        output_path=output_path,\n        pem_to_julia=pem_to_julia,\n        fidelity_function=fidelity_function,\n    )\n    # Get julia environment\n    jl_environment = get_jl_env(version) if version is not None else None\n\n    if run_kwargs is None:\n        run_kwargs = {}\n    elif run_kwargs == \"default\":\n        run_kwargs = {\"check\": True}\n\n    # Run Julia\n    t1 = time.time()\n    sim_results = run_hallthruster_jl(json_data, jl_env=jl_environment, jl_script=julia_script, **run_kwargs)\n    t2 = time.time()\n\n    # Format QOIs for PEM\n    thruster_outputs = _convert_to_pem(sim_results, pem_to_julia)\n\n    # Raise an exception if thrust or beam current are negative (non-physical cases)\n    thrust = thruster_outputs.get(\"T\", 0)\n    beam_current = thruster_outputs.get(\"I_B0\", 0)\n    if thrust &lt; 0 or beam_current &lt; 0:\n        raise ValueError(f\"Exception due to non-physical case: thrust={thrust} N, beam current={beam_current} A\")\n\n    thruster_outputs[\"model_cost\"] = t2 - t1  # seconds\n\n    if output_path is not None:\n        output_file = Path(json_data[\"postprocess\"].get(\"output_file\"))\n        thruster_outputs[\"output_path\"] = output_file.relative_to(Path(output_path).resolve()).as_posix()\n\n    return thruster_outputs\n</code></pre>"},{"location":"reference/models/thruster/#hallmd.models.thruster.run_hallthruster_jl","title":"<code>run_hallthruster_jl(json_input, jl_env=None, jl_script=None, **kwargs)</code>","text":"<p>Python wrapper for <code>HallThruster.run_simulation(json_input)</code> in Julia.</p> PARAMETER DESCRIPTION <code>json_input</code> <p>either a dictionary containing <code>config</code>, <code>simulation</code>, and <code>postprocess</code> options for HallThruster.jl, or a string/Path containing a path to a JSON file with those inputs.</p> <p> TYPE: <code>dict | str | Path</code> </p> <code>jl_env</code> <p>The julia environment containing HallThruster.jl. Defaults to global Julia environment.</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> <code>jl_script</code> <p>path to a custom Julia script to run. The script should accept the input json file path as a command line argument. Defaults to just calling <code>HallThruster.run_simulation(input_file)</code>.</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>additional keyword arguments to pass to <code>subprocess.run</code> when calling the Julia script.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>dict</code> <p><code>dict</code> of <code>Hallthruster.jl</code> outputs. The specific outputs depend on the settings provided in the <code>postprocess</code> dict in the input. If <code>postprocess['output_file']</code> is present, this function will also write the requested outputs and restart information to that file.</p> Source code in <code>src/hallmd/models/thruster.py</code> <pre><code>def run_hallthruster_jl(\n    json_input: dict | str | Path, jl_env: str | Path = None, jl_script: str | Path = None, **kwargs\n) -&gt; dict:\n    \"\"\"Python wrapper for `HallThruster.run_simulation(json_input)` in Julia.\n\n    :param json_input: either a dictionary containing `config`, `simulation`, and `postprocess` options for\n            HallThruster.jl, or a string/Path containing a path to a JSON file with those inputs.\n    :param jl_env: The julia environment containing HallThruster.jl. Defaults to global Julia environment.\n    :param jl_script: path to a custom Julia script to run. The script should accept the input json file path as\n                      a command line argument. Defaults to just calling `HallThruster.run_simulation(input_file)`.\n    :param kwargs: additional keyword arguments to pass to `subprocess.run` when calling the Julia script.\n\n    :returns: `dict` of `Hallthruster.jl` outputs. The specific outputs depend on the settings\n              provided in the `postprocess` dict in the input. If `postprocess['output_file']` is present,\n              this function will also write the requested outputs and restart information to that file.\n    \"\"\"\n    # Read JSON input from file if path provided\n    if isinstance(json_input, str | Path):\n        with open(json_input, \"r\") as fp:\n            json_input = json.load(fp)\n\n    tempfile_args = dict(suffix=\".json\", prefix=\"hallthruster_jl_\", mode=\"w\", delete=False, encoding=\"utf-8\")\n\n    # Get output file path. If one not provided, create a temporary\n    temp_out = False\n    if \"output_file\" in json_input.get(\"postprocess\", {}):\n        output_file = Path(json_input[\"postprocess\"].get(\"output_file\"))\n    elif \"output_file\" in json_input.get(\"input\", {}).get(\"postprocess\", {}):\n        output_file = Path(json_input[\"input\"][\"postprocess\"].get(\"output_file\"))\n    else:\n        temp_out = True\n        fd_out = tempfile.NamedTemporaryFile(**tempfile_args)\n        output_file = Path(fd_out.name)\n        fd_out.close()\n\n        if json_input.get(\"input\"):\n            json_input[\"input\"].setdefault(\"postprocess\", {})\n            json_input[\"input\"][\"postprocess\"][\"output_file\"] = str(output_file.resolve())\n        else:\n            json_input.setdefault(\"postprocess\", {})\n            json_input[\"postprocess\"][\"output_file\"] = str(output_file.resolve())\n\n    # Dump input to temporary file\n    fd = tempfile.NamedTemporaryFile(**tempfile_args)\n    input_file = fd.name\n    json.dump(json_input, fd, ensure_ascii=False, indent=4)\n    fd.close()\n\n    # Run HallThruster.jl on input file\n    if jl_script is None:\n        cmd = [\n            \"julia\",\n            \"--startup-file=no\",\n            \"-e\",\n            f'using HallThruster; HallThruster.run_simulation(raw\"{input_file}\")',\n        ]\n    else:\n        cmd = [\"julia\", \"--startup-file=no\", \"--\", str(Path(jl_script).resolve()), input_file]\n\n    if jl_env is not None:\n        if Path(jl_env).exists():\n            cmd.insert(1, f\"--project={Path(jl_env).resolve()}\")\n        else:\n            raise ValueError(\n                f\"Could not find Julia environment {jl_env}. Please create it first. \"\n                f\"See https://github.com/JANUS-Institute/HallThrusterPEM/blob/main/scripts/install_hallthruster.py\"\n            )\n\n    try:\n        subprocess.run(cmd, **kwargs)\n    finally:\n        # Delete temporary input file\n        os.unlink(input_file)\n\n    # Load output data\n    with open(output_file, \"r\") as fp:\n        output_data = json.load(fp)\n\n    if temp_out:\n        os.unlink(output_file)\n        if d := output_data.get(\"postprocess\"):\n            if \"output_file\" in d:\n                del d[\"output_file\"]\n        if d := output_data.get(\"input\"):\n            if d2 := d.get(\"postprocess\"):\n                if \"output_file\" in d2:\n                    del d2[\"output_file\"]\n\n    return output_data\n</code></pre>"},{"location":"theory/summary/","title":"Summary","text":"<p>The overarching goal of this software package is summarized by the abstract:</p> <p>We study the analysis and refinement of a predictive engineering model for enabling rapid prediction of Hall thruster system performance across a range of operating and environmental conditions and epistemic and aleatoric uncertainties. In particular, we describe an approach by which experimentally-observed facility effects are assimilated into the model, with a specific focus on facility background pressure. We propose a multifidelity, multidisciplinary approach for Bayesian calibration of an integrated system comprised of a set of component models. Furthermore, we perform uncertainty quantification over the calibrated model to assess the effects of epistemic and aleatoric uncertainty. This approach is realized on a coupled system of cathode, thruster, and plume models that predicts global quantities of interest (QoIs) such as thrust, efficiency, and discharge current as a function of operating conditions such as discharge voltage, mass flow rate, and background chamber pressure. As part of the calibration and prediction, we propose a number of metrics for assessing predictive model quality. Based on these metrics, we found that our proposed framework produces a calibrated model that is more accurate, sometimes by an order of magnitude, than engineering models using nominal parameters found in the literature. We also found for many QoIs that the remaining uncertainty was not sufficient to account for discrepancy with experimental data, and that existing models for facility effects do not sufficiently capture experimental trends. Finally, we confirmed through a global sensitivity analysis the prior intuition that anomalous transport dominates model uncertainty, and we conclude by suggesting several paths for future model improvement. We envision that the proposed metrics and procedures can guide the refinement of future model development activities.</p> <ul> <li>Eckels et al 2024</li> </ul> <p>Our first iteration of this framework comes in the form of the three-component feedforward system illustrated below:</p> <p></p> <p>Fig 1. The three-component feedforward Hall thruster model (Eckels et al 2024).</p> <p>This software package provides the testbench for rapid iteration and improvement of Hall thruster models in this multidisciplinary framework. Please see the scripts folder for our current progress. Please see the journal paper for specific details on the theory and background of the models and methods.</p>"}]}